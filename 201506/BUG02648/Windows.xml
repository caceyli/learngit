<?xml version="1.0" encoding="UTF-8"?>
<!--
**********************************************************************
*
* Copyright (c) 2007-2008 BDNA Corporation.
* All Rights Reserved. BDNA products and services are protected
* by the following U.S. patent: #6,988,134. BDNA is trademark of
* BDNA Corporation.
*
* ******BDNA CONFIDENTIAL******
*
* The following code was developed and is owned by BDNA Corporation.
* This code is confidential and may contain trade secrets.  The code
* must not be distributed to any party outside of BDNA Corporation
* without written permission from BDNA Corporation.  The code may be
* covered by patents, patents pending, or patents applied for in the
* US or elsewhere.
*
**********************************************************************
-->
<!DOCTYPE bdna SYSTEM "bdna.dtd">

<!-- ............................................................... -->
<!-- .......           Windows OS fingerprints           ........... -->
<!-- ............................................................... -->
<module 
    name="com.bdna.modules.os.Windows" 
    displayLabel="Windows"
    requiredPlatformVersion="030300"         
    version="1" 
    lastCompatibleVersion="1">
    
    <moduleDependency parentModuleName="com.bdna.modules.common.Discovery" parentModuleVersion="1" />
    <moduleDependency parentModuleName="com.bdna.modules.common.DiscoveryInstall" parentModuleVersion="1" />
    <moduleDependency parentModuleName="com.bdna.modules.common.SystemDiscovery" parentModuleVersion="1" />
    <moduleDependency parentModuleName="com.bdna.modules.os.OperatingSystemTypes" parentModuleVersion="1" />
    <moduleDependency parentModuleName="com.bdna.modules.app.ActiveDirectory" parentModuleVersion="1" />

    <!-- Windows fingerprint -->
    <target type="root.types.resource.software.operatingSystem.Windows" />

    <!-- ............................................................... -->
    <!-- .......         Windows connection setup            ........... -->
    <!-- ............................................................... -->

    <!-- Connection methods using script args -->
    <element
        elementName="wincs"
        elementTypePath="root.types.collection.connectionMethod.windows"
        displayLabel="Windows Collection Server Connection Methods"
        isTemplate="true" collectionLevel="2">
    </element>

    <element
        elementName="defaultwincs"
        elementTypePath="root.types.collection.connectionMethod.windows.wincs"
        displayLabel="Windows"
        isTemplate="true" collectionLevel="2">
        <attribute attributeName="scriptTable" dataType="string" displayLabel="Script Table" />
        <attribute attributeName="userName" dataType="string" displayLabel="User Name and Domain" />
        <attribute attributeName="password" dataType="string" displayLabel="Password" isEncrypted="true"/>
    </element>

<!-- Disable NoCred credentials to disallow this type of collection see bug# 8959    
    <element
        elementName="windowsNoCred"
        elementTypePath="root.types.collection.connectionMethod"
        displayLabel="Windows No Credential Connection Methods"
        isTemplate="true" collectionLevel="2">
    </element>
-->

    <!-- Default elements -->

    <!-- the default credential for Windows collection for the CLE -->
<!-- Disable NoCrud credentials to disallow this type of collection see bug# 8959    
    <element
        elementName="windowsNoCred"
        elementTypePath="root.types.collection.connectionMethod.windowsNoCred"
        parentPath="root.$bdna.CLE1"
        isTemplate="false" />
    <data elementPath="root.$bdna.CLE1.windowsNoCred" attributeName="agentType">wincs</data>        
-->

    <element
        elementName="wincs"
        elementTypePath="root.types.collection.connectionMethod.windows.wincs.defaultwincs"
        parentPath="root.$bdna.CLE1"
        isTemplate="false" />
    <data elementPath="root.$bdna.CLE1.wincs" attributeName="scriptTable">ConnWincsScript</data>        
    <data elementPath="root.$bdna.CLE1.wincs" attributeName="agentType">wincs</data>        

    <!-- ............................................................... -->
    <!-- .......            Windows declarations             ........... -->
    <!-- ............................................................... -->
    
    <element elementName="Windows"
             elementTypePath="root.types.resource.software.operatingSystem"
             displayLabel="Windows"
             icon="ico_os_windows.xsl"
             isTemplate="true" >

        <attribute attributeName="systemData" dataType="text" displayLabel="System Information"/>
        <attribute attributeName="licenseKey" dataType="string" displayLabel="License Key"/>
        <attribute attributeName="appProductID" dataType="string" displayLabel="Product ID"/>
        <attribute attributeName="appLicenseType" dataType="string" displayLabel="License Type"/>
        <attribute attributeName="hwIdentNum" dataType="string" displayLabel="BIOS Hardware Identification Number"/>
        <attribute attributeName="hwUUID" dataType="string" displayLabel="Hardware UUID"/>
        <attribute attributeName="SMBIOSAssetTag" dataType="string" displayLabel="System Enclosure Asset Tag"/>
        <attribute attributeName="osBuildNumber" dataType="string" displayLabel="OS Build Number" />
        <attribute attributeName="osLanguage" dataType="string" displayLabel="OS Language" />
        <attribute attributeName="serviceRelease" dataType="string" displayLabel="OS Service Release Version" />
        <attribute attributeName="productType" dataType="string" displayLabel="Product Type" />
        <attribute attributeName="patches" dataType="text" displayLabel="patches" />
        <attribute attributeName="installedSoftwareDetails" dataType="udt" displayLabel="Installed Windows Software Details"><![CDATA[InstallAppList]]></attribute>
        <!--
        <attribute attributeName="powerSettingsDetails" dataType="udt" displayLabel="Power Settings"><![CDATA[PowerSettingsUDT]]></attribute>
        -->
        <attribute attributeName="winProcesses" dataType="udt" displayLabel="Windows Processes"><![CDATA[WindowsProcessesUDT]]></attribute>
        <attribute attributeName="winShare" dataType="udt" displayLabel="Windows Share Information"><![CDATA[WindowsShare]]></attribute>
        <attribute attributeName="userInfo" dataType="udt" displayLabel="Windows User Information"><![CDATA[WindowsUserInfo]]></attribute>
        <attribute attributeName="services" dataType="udt" displayLabel="Windows Services"><![CDATA[WindowsServicesUDT]]></attribute>
        <attribute attributeName="numServices" dataType="number" displayLabel="Number of Windows Services" />
        <attribute attributeName="monitors" dataType="udt" isList="true" displayLabel="Windows Desktop Monitors"><![CDATA[WindowsMonitorUDT]]></attribute>
        <attribute attributeName="numMonitors" dataType="number" displayLabel="Number of Monitors" />
        <attribute attributeName="winNics" dataType="udt" isList="true" displayLabel="NICs"><![CDATA[WinNics]]></attribute>
        <attribute attributeName="imageName" dataType="string" displayLabel="Image Name"/>
        <attribute attributeName="isDomainMember" dataType="string" displayLabel="Member of Registered Domain"/>
        <attribute attributeName="serviceSUData" dataType="text" displayLabel="ServiceSU software usage data"/>
        <!-- Derived attributes -->
        <attribute attributeName="volumeSN" dataType="string" displayLabel="C Drive Volume Serial Number"/>
        <attribute attributeName="windowsTypingData" dataType="string" displayLabel="Identification String for typing"/>
        <!-- Last Logon User -->
        <attribute attributeName="lastLogon" dataType="string" displayLabel="Last Logon User"/>
        <!-- De-dupping support -->
        <attribute attributeName="__WindowsOSDomainAndComputerName_deduppingValidatedBucket" dataType="string" displayLabel="Private attribute for doing Level-1/2 Windows domain/computer name de-dupping" />
        <!-- Windows Cleanup Trace Status -->
        <attribute attributeName="removeWindowsProfileStatus" dataType="number" displayLabel="Remove Windows Profile Status" />
        <attribute attributeName="systemDSNDetails" dataType="text" displayLabel="System DSN Details" />
        <attribute attributeName="odbcDriversDetails" dataType="udt" isList="true" displayLabel="ODBC Drivers"><![CDATA[ODBCDriverUDT]]></attribute>
        <attribute attributeName="rsopUserSettings" dataType="text" displayLabel="RSOP Group Policy User Settings" />
        <attribute attributeName="rsopComputerSettings" dataType="text" displayLabel="RSOP Group Policy Computer Settings" />
        <attribute attributeName="ntpW32tmCmd" dataType="string" displayLabel="NTP w32tm command"/>
        <attribute attributeName="IMEI" dataType="string" displayLabel="IMEI"/>
        <attribute attributeName="ProviderName" dataType="string" displayLabel="Provider Name"/>

        <attributeSet attributeSetName="WinTypingStatic"
            collectorName="WinTypingStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic Windows Static for Typing">
            <attributeSetEntry attributeName="windowsTypingData" />
        </attributeSet>
<!-- Disable NoCred credentials to disallow this type of collection see bug# 8959    
        <attributeSet attributeSetName="WinStaticNoCred"
            collectorName="WinStaticNoCredCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic Windows Static With No Credentials">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
-->    
        <attributeSet attributeSetName="WinStaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic Windows Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>

<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="WinSoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic Windows Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>
      
        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="Windows3_1"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows 3.1"
             isTemplate="true">
        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="Windows95"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows 95"
             isTemplate="true">
        <attributeSet attributeSetName="Win95Static"
            collectorName="Win95StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 95 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win95AppStatic"
            collectorName="Win95AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 95 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win95StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 95 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
        <attributeSet attributeSetName="Win95ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 95 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win95SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 95 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win95RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 95 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win95NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 95 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="Windows98"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows 98"
             isTemplate="true">
        <attributeSet attributeSetName="Win98Static"
            collectorName="Win98StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 98 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win98AppStatic"
            collectorName="Win98AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 98 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win98ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 98 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="Win98StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 98 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win98SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 98 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win98RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 98 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win98NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 98 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
    </element>
    <element elementName="WindowsNT"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows NT"
             isTemplate="true">
        <attributeSet attributeSetName="WinNTStatic"
            collectorName="WinNTStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows NT Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="WinNTAppStatic"
            collectorName="WinNTAppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows NT App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails"/>
            <attributeSetEntry attributeName="patches" />
        </attributeSet>

<!--        
        <attributeSet attributeSetName="WinNTStaticNoCred"
            collectorName="WinStaticNoCredCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NT Static With No Credentials">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
-->    
        <attributeSet attributeSetName="WinNTODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NT ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="WinNTStaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NT Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="WinNTSoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NT Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="WinNTRSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NT RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="WinNTNTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows NT NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="WindowsME"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows ME"
             isTemplate="true">
        <attributeSet attributeSetName="WinMEStatic"
            collectorName="WinMEStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows ME Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="WinMEAppStatic"
            collectorName="WinMEAppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows ME App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="WinMEODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows ME ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="WinMEStaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows ME Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="WinMESoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows ME Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="WinMERSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows ME RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="WinMENTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows ME NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="Windows2000"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows 2000"
             isTemplate="true">
        <attributeSet attributeSetName="Win2KStatic"
            collectorName="Win2KStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2000 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win2KAppStatic"
            collectorName="Win2KAppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2000 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win2KODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2000 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
<!--        
        <attributeSet attributeSetName="Win2KStaticNoCred"
            collectorName="WinStaticNoCredCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2000 Static With No Credentials">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
-->    
        <attributeSet attributeSetName="Win2000StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2000 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win2000SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2000 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win2000RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2000 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win2000NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2000 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="WindowsXP"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows XP"
             isTemplate="true">
        <attributeSet attributeSetName="WinXPStatic"
            collectorName="WinXPStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows XP Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="WinXPAppStatic"
            collectorName="WinXPAppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows XP App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="WinXPODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows XP ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>

<!--        
        <attributeSet attributeSetName="WinXPStaticNoCred"
            collectorName="WinStaticNoCredCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows XP Static With No Credentials">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
-->    
        <attributeSet attributeSetName="WinXPStaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows XP Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="WinXPSoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows XP Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="RemoveWindowsXPProfile"
                      collectorName="RemoveWindowsXPProfileCollector"
                      collectionInterval="-1"
                      displayLabel="Remove Windows XP Profile">
            <attributeSetEntry attributeName="removeWindowsProfileStatus" />
        </attributeSet>        
        <attributeSet attributeSetName="WinXPRSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows XP RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="WinXPNTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows XP NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>        
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="Windows2003"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows Server 2003"
             isTemplate="true">
        <attributeSet attributeSetName="Win2003Static"
            collectorName="Win2003StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2003 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win2003AppStatic"
            collectorName="Win2003AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2003 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win2003ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2003 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>

<!--        
        <attributeSet attributeSetName="Win2003StaticNoCred"
            collectorName="WinStaticNoCredCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2003 Static With No Credentials">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
-->    
        <attributeSet attributeSetName="Win2003StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2003 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win2003SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2003 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win2003RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2003 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win2003NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2003 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    <element elementName="WindowsVista"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows Vista"
             isTemplate="true">
        <attributeSet attributeSetName="WinVistaStatic"
            collectorName="WinVistaStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows Vista Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="WinVistaAppStatic"
            collectorName="WinVistaAppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows Vista Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="WinVistaODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows Vista ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="WinVistaStaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows Vista Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="WinVistaSoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows Vista Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="WinVistaRSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows Vista RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="WinVistaNTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows Vista NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>

    <element elementName="Windows2008"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows Server 2008"
             isTemplate="true">
        <attributeSet attributeSetName="Win2008Static"
            collectorName="Win2008StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2008 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win2008AppStatic"
            collectorName="Win2008AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2008 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win2008ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2008 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="Win2008StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2008 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win2008SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2008 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win2008RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2008 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win2008NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2008 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>

    <element elementName="Windows7"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows 7"
             isTemplate="true">
        <attributeSet attributeSetName="Win7Static"
            collectorName="Win7StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 7 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win7AppStatic"
            collectorName="Win7AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 7 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win7ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 7 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="Win7StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 7 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win7SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 7 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win7RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 7 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win7NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 7 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>

    <element elementName="Windows2012"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows Server 2012"
             isTemplate="true">
        <attributeSet attributeSetName="Win2012Static"
            collectorName="Win2012StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2012 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win2012AppStatic"
            collectorName="Win2012AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 2012 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win2012ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2012 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="Win2012StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2012 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win2012SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2012 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win2012RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2012 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win2012NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 2012 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>

    <element elementName="Windows8"
             elementTypePath="root.types.resource.software.operatingSystem.Windows"
             displayLabel="Windows 8"
             isTemplate="true">
        <attributeSet attributeSetName="Win8Static"
            collectorName="Win8StaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 8 Static">
            <attributeSetEntry attributeName="systemData" />
        </attributeSet>
        <attributeSet attributeSetName="Win8AppStatic"
            collectorName="Win8AppStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="3600000"
            displayLabel="Windows 8 App Static">
            <attributeSetEntry attributeName="installedSoftwareDetails" />
            <attributeSetEntry attributeName="patches" />
        </attributeSet>
        <attributeSet attributeSetName="Win8ODBCDriversCollection"
            collectorName="ODBCDriversCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 8 ODBC Drive Collection">
            <attributeSetEntry attributeName="odbcDriversDetails" />
            <attributeSetEntry attributeName="systemDSNDetails" />
        </attributeSet>
        <attributeSet attributeSetName="Win8StaticDomainCheck"
            collectorName="WinStaticDomainCheckCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 8 Static Domain Check">
            <attributeSetEntry attributeName="isDomainMember" />
        </attributeSet>
<!-- Disabling SU collection for 6.1.0 as per bug #17304
        <attributeSet attributeSetName="Win8SoftwareUsage"
            collectorName="WinSoftwareUsageCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 8 Software Usage">
            <attributeSetEntry attributeName="serviceSUData" />
        </attributeSet>
-->
        <attributeSet attributeSetName="Win8RSOPPropertiesCollection"
            collectorName="RSOPPropertiesCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 8 RSOP Group Policy Collection">
            <attributeSetEntry attributeName="rsopUserSettings" />
            <attributeSetEntry attributeName="rsopComputerSettings" />
        </attributeSet>
        <attributeSet attributeSetName="Win8NTPTimeServerCollection"
            collectorName="NTPTimeServerCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Windows 8 NTP Time Server Collection">
            <attributeSetEntry attributeName="ntpServer" />
        </attributeSet>

        <attrSysDefValue attributeName="osWkgrpDomain">__BDNA_DEFAULT__</attrSysDefValue>
        <attrSysDefValue attributeName="manufacturer">Microsoft Corporation</attrSysDefValue>
        <attrSysDefValue attributeName="ntpW32tmCmd">w32tm /dumpreg /subkey:Parameters</attrSysDefValue>
    </element>
    
    <element
        elementName="WinSIMCardFilePropFootprint"
        elementTypePath="root.types.footprint"
        displayLabel="WinSIMCardFilePropFootprint"
        isTemplate="true">
        <attributeSet
            attributeSetName="WinSIMCardFilePropFootprintStatic"
            displayLabel="WinSIMCardFilePropFootprintStatic"
            collectorName="WinSIMCardFilePropFootprintStatic_collector"
            maxScriptRunTime="1800000"
            collectionInterval="7200000">
        <attributeSetEntry attributeName="commandResult" />
        </attributeSet>
    </element>

    <package name="WinSIMCard" displayLabel = "Windows SIM Card">
    </package>


    <relationship
        parentType="root.types.resource.software.operatingSystem.Windows"
        childType="root.types.footprint.WinSIMCardFilePropFootprint"
    />

   <collector
        collectorName="WinSIMCardFilePropFootprintStatic_collector"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinFilePropertiesScript">
        <collectionParams
            typeElementFullName="root.types.footprint.WinSIMCardFilePropFootprint"
            attributeName="filePath">
        </collectionParams>
        <collectionParams
            typeElementFullName="root.types.footprint.WinSIMCardFilePropFootprint"
            attributeName="fileCommand">
        </collectionParams>
        <scriptRef name="WinFilePropertiesScript" scriptType="collection" seqNum="1"  />
    </collector>

    <rule
        name="createWinSIMCardFilePropFootprint"
        weight="50"
        generated="true">
        <search
            variable="osw"
            pattern="root.types.resource.software.operatingSystem.Windows">
        </search>
        <conclusion type="java" argumentList="com.bdna.modules.os Windows createWinSIMCardFilePropFootprint gnu.regexp.*">
        <![CDATA[
            String parent = (String)args.get("osw.elementFullName");
            String eltName = "WinSIMCardfileProp";
            String eltFullName = parent + "." + eltName;
            String result = "<result>";
            result += elementXML(eltName, "root.types.footprint.WinSIMCardFilePropFootprint", parent);
            result += _j4_dataXML(eltFullName, "name", "Footprint to collect WinSIMCard file properties");
            result += _j4_dataXML(eltFullName, "filePath", "netsh mbn show interface");
            result += _j4_dataXML(eltFullName, "fileCommand", "executeCommand");
            result += "</result>";
            return result;
        ]]>
        </conclusion>
    </rule>

    <rule
        name="findWinSIMCardFileProperrties"
        weight="90" >
        <search
            variable="osw"
            pattern="root.types.resource.software.operatingSystem.Windows">
        </search>
        <search
            variable="fp"
            pattern="root.types.footprint.WinSIMCardFilePropFootprint">
            <use attribute="commandResult"  />
        </search>
        <simpleJoinFilter lhsVariable="osw" operator="parentOf" rhsVariable="fp" />
        <conclusion type="perl">
            <![CDATA[
            our $result = "<result>";
            my $eltFullName = $osw{"elementFullName"};
            my $commandResult = $fp{"commandResult"};
            foreach my $line (split(/\n/, $commandResult)) {
               if ($line =~ /\s*Device\s*Id\s*:\s*(.+)/) {
                   $result .= &dataXML($eltFullName, 'IMEI', $1);
               }
               if ($line =~ /\s*Provider\s*Name\s*:\s*(.+)/) {
                   $result .= &dataXML($eltFullName, 'ProviderName', $1);
               }
            }
            $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <element
        elementName="WindowsFileScanCollectorFootprint"
        elementTypePath="root.types.footprint"
        displayLabel="Windows File Scan Collection Footprint on Windows"
        isTemplate="true" >
        <attribute attributeName="taskName" dataType="string" displayLabel="Task Name" />
        <attribute attributeName="filter" dataType="string" displayLabel="Search Filter Raw" />
        <attribute attributeName="drive" dataType="string" displayLabel="Disk Drive to Scan" />
        <attribute attributeName="startDateTime" dataType="string" displayLabel="DateTime of Scan Task Begins" />
        <attribute attributeName="endDateTime" dataType="string" displayLabel="DateTime of Scan Task Ends" />
        <attribute attributeName="searchFilterString" dataType="string" displayLabel="Search Filter" />
        <attribute attributeName="fileSearchResult" dataType="udt" displayLabel="File Name Scan Result Details"><![CDATA[FileSearchResultUDT]]></attribute>
        <attribute attributeName="driveName" dataType="string" displayLabel="Drive Name" />
        <attribute attributeName="driveType" dataType="string" displayLabel="Drive Type" />
        <attribute attributeName="mountPoint" dataType="string" displayLabel="Mount Point" />
        <attribute attributeName="capacity" dataType="string" displayLabel="Capacity" />
        <attribute attributeName="isLocal" dataType="string" displayLabel="Is Local" />
        <attribute attributeName="splitQuery" dataType="number" displayLabel="Split Query" />

        <attributeSet attributeSetName="WindowsFileNameScan"
            collectorName="WindowsFileNameScanStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="18000000"
            displayLabel="Windows File Name Scan">
            <attributeSetEntry attributeName="searchFilterString" />
            <attributeSetEntry attributeName="fileSearchResult" />
            <attributeSetEntry attributeName="startDateTime" />
            <attributeSetEntry attributeName="endDateTime" />
        </attributeSet>
    </element>
    <relationship parentType="root.types.resource.software.operatingSystem.Windows" childType="root.types.footprint.WindowsFileScanCollectorFootprint"/>

    <element
        elementName="RAIDDataCollectorFootprint"
        elementTypePath="root.types.footprint"
        displayLabel="Windows RAID Controller Info Collection Footprint on Windows"
        isTemplate="true" >
        <attribute attributeName="RAIDPhyData" dataType="text" displayLabel="Raw RAID Physical Disks Data"/>
        <attribute attributeName="RAIDCntlrData" dataType="text" displayLabel="Raw RAID Controllers Data" />
        <attribute attributeName="RAIDLogData" dataType="text" displayLabel="Raw RAID Logical Disks Data" />
        <attribute attributeName="physicalDisks" dataType="text" displayLabel="Physical Disks" />
        <attribute attributeName="logicalDisks" dataType="text" displayLabel="Logical Disks" />
        <attribute attributeName="RAIDControllers" dataType="text" displayLabel="RAID Controllers" />

        <attributeSet attributeSetName="RAIDDataStatic"
            collectorName="RAIDDataStaticCollector"
            collectionInterval="-1"
            maxScriptRunTime="1800000"
            displayLabel="Generic Windows RAID Controller Collection Static">
            <attributeSetEntry attributeName="RAIDPhyData" />
            <attributeSetEntry attributeName="RAIDCntlrData" />
            <attributeSetEntry attributeName="RAIDLogData" />
            <attributeSetEntry attributeName="physicalDisks" />
            <attributeSetEntry attributeName="logicalDisks" />
            <attributeSetEntry attributeName="RAIDControllers" />
        </attributeSet>

    </element>
    <relationship parentType="root.types.resource.software.operatingSystem.Windows" childType="root.types.footprint.RAIDDataCollectorFootprint"/>

<!-- Windows UI Task -->
    <element elementName="Windows"
        parentPath="root.$bdna.uiResourceToCredentialFolder"
        elementTypePath="root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
        displayLabel="Instance of Bucketing Details of type root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
        isTemplate="false" />

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="packageNames"><![CDATA[WindowsPkg]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="taskType"><![CDATA[Inventory]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="uiDisplayOrder"><![CDATA[2]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="uiResourceDisplayLabel"><![CDATA[Windows]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="collectionLevel"><![CDATA[2]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
      attributeName="uiResourceAlternativeDisplayLabel"><![CDATA[Scan for Windows System and Applications Information]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
      attributeName="uiResourceAlternativeDescription"><![CDATA[This task performs complete L2 scan and collects both System information and Applications information]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
      attributeName="uiResourcePeerTasks"><![CDATA[WindowsPkgSys,Windows]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="connMethodNames"><![CDATA[root.types.collection.connectionMethod.windows.wincs.defaultwincs]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="connMethodDependency"><![CDATA[]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.Windows"
        attributeName="testableConns"><![CDATA[root.types.collection.connectionMethod.windows.wincs.defaultwincs<BDNA,1>Yes]]></data>


<!-- WindowsPkgSys UI Task -->
    <element elementName="WindowsPkgSys"
        parentPath="root.$bdna.uiResourceToCredentialFolder"
        elementTypePath="root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
        displayLabel="Instance of Bucketing Details of type root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
        isTemplate="false" />

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="packageNames"><![CDATA[WindowsPkgSys]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="taskType"><![CDATA[Inventory]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="uiDisplayOrder"><![CDATA[1]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="uiResourceDisplayLabel"><![CDATA[Scan for Windows System Information Only]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="collectionLevel"><![CDATA[2]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
      attributeName="uiResourceDescription"><![CDATA[This task performs basic L2 scan and collects only System information]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
      attributeName="uiResourceHide"><![CDATA[1]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="connMethodNames"><![CDATA[root.types.collection.connectionMethod.windows.wincs.defaultwincs]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="connMethodDependency"><![CDATA[]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsPkgSys"
        attributeName="testableConns"><![CDATA[root.types.collection.connectionMethod.windows.wincs.defaultwincs<BDNA,1>Yes]]></data>


   <element elementName="RemoveWindowsProfile"
         parentPath="root.$bdna.uiResourceToCredentialFolder"
         elementTypePath="root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
         displayLabel="Instance of Bucketing Details of type root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
         isTemplate="false" />

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="packageNames"><![CDATA[RemoveWindowsXPProfilePkg]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="taskType"><![CDATA[Maintenance]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="collectionLevel"><![CDATA[2]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="uiDisplayOrder"><![CDATA[6]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="uiResourceDisplayLabel"><![CDATA[Remove Windows XP Profile]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="connMethodNames"><![CDATA[root.$bdna.uiResourceToCredentialFolder.Windows<BDNA,>root.types.collection.connectionMethod.windows.wincs.defaultwincs]]>
    </data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.RemoveWindowsProfile"
      attributeName="attributeSetDetails"><![CDATA[2<BDNA,1>Remove Windows XP Profile<BDNA,1>RemoveWindowsXPProfile]]></data>
   

   <element elementName="WindowsFileNameScan"
         parentPath="root.$bdna.uiResourceToCredentialFolder"
         elementTypePath="root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
         displayLabel="Instance of Bucketing Details of type root.types.internal.folder.uiResourceToCredentialFolder.uiResourceToCredentialDetails"
         isTemplate="false" />

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="packageNames"><![CDATA[WindowsFileNameScanPkg]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="taskType"><![CDATA[Maintenance]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="collectionLevel"><![CDATA[2]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="uiDisplayOrder"><![CDATA[7]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="uiResourceDisplayLabel"><![CDATA[Windows File Name Scan]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="connMethodNames"><![CDATA[root.$bdna.uiResourceToCredentialFolder.Windows<BDNA,>root.types.collection.connectionMethod.windows.wincs.defaultwincs]]></data>

    <data elementPath="root.$bdna.uiResourceToCredentialFolder.WindowsFileNameScan"
      attributeName="attributeSetDetails"><![CDATA[2<BDNA,1>Windows File Name Scan<BDNA,1>WindowsFileNameScan]]></data>

 
    <!-- ............................................................... -->
    <!-- .......          AttributeSet Packages              ........... -->
    <!-- ............................................................... -->

    <package name="WindowsPkgSys" displayLabel="Windows Level 2 - Systems Information Only">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>
    
    <package name="WindowsL1" displayLabel = "Windows Level 1 (no credentials)">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>

    <packageRelationship parentPackage="level1" childPackage="WindowsL1" />

    <packageRelationship parentPackage="WindowsPkg" childPackage="software" />
<!--     <packageRelationship parentPackage="WindowsPkg" childPackage="fileSystems" /> -->

    <package name="WindowsL2" displayLabel = "Windows Level 2 (operating system credentials)">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>

    <package name="WindowsL2Sys" displayLabel = "Windows Level 2 - System Information (operating system credentials)">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>
    
    <package name="desktopSoftware" displayLabel="Desktop Software">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
        <depend name="operatingSystems" />
    </package>
    
    <package name="RemoveWindowsXPProfilePkg" displayLabel="Remove Windows XP Profile" >
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>

    <package name="WindowsFileNameScanPkg" displayLabel = "Windows File Name Scan">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>


<!-- Disabling SU collection for 6.1.0 as per bug #17304
    <package name="WindowsSoftwareUsage" displayLabel="Windows Software Usage">
        <depend name="IPAddresses" />
        <depend name="hardwareDevices" />
    </package>
-->

    <packageRelationship parentPackage="Windows" childPackage="WindowsL1" />
    <packageRelationship parentPackage="WindowsPkg" childPackage="WindowsL1" />
    <packageRelationship parentPackage="WindowsPkgSys" childPackage="WindowsL1" />

    <packageRelationship parentPackage="Windows" childPackage="WindowsL2" />
    <packageRelationship parentPackage="WindowsPkg" childPackage="WindowsL2" />
    <packageRelationship parentPackage="WindowsPkgSys" childPackage="WindowsL2Sys" />

    <packageRelationship parentPackage="WindowsL2" childPackage="WinSIMCard" />
    <packageRelationship parentPackage="WindowsL2" childPackage="WinSIMCard" />
    <packageRelationship parentPackage="WindowsL2Sys" childPackage="WinSIMCard" />
    <packageAttributeSet packageName="WinSIMCard" attributeSetName="WinSIMCardFilePropFootprintStatic"  />

    <packageRelationship parentPackage="software" childPackage="desktopSoftware" />
    <packageAttributeSet packageName="SNMP" attributeSetName="RAIDDataStatic" /> 
    <packageAttributeSet packageName="hardwareDevices" attributeSetName="RAIDDataStatic" /> 

<!-- Disabling SU collection for 6.1.0 as per bug #17304
    <packageRelationship parentPackage="WindowsL2" childPackage="WindowsSoftwareUsage" />
-->

    <packageAttributeSet packageName="fileSystems" attributeSetName="WinTypingStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="RAIDDataStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win2KStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win95Static" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win98Static" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinMEStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinNTStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinXPStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinVistaStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win2008Static" />    
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win7Static" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win2012Static" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win8Static" />

    <packageAttributeSet packageName="fileSystems" attributeSetName="Win2KAppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win95AppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win98AppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinMEAppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinNTAppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinXPAppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="WinVistaAppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win2008AppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win7AppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win2012AppStatic" />
    <packageAttributeSet packageName="fileSystems" attributeSetName="Win8AppStatic" />


<!--        
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinStaticNoCred" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinNTStaticNoCred" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2KStaticNoCred" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinXPStaticNoCred" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2003StaticNoCred" />
-->

    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinStaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win95StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win98StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinNTStaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinMEStaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2000StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinXPStaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2003StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="WinVistaStaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2008StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2008StaticDomainCheck" />    
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win7StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win2012StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="Win8StaticDomainCheck" />
    <packageAttributeSet packageName="WindowsL1" attributeSetName="RAIDDataStatic"/>
   
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinTypingStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2KStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win95Static" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win98Static" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinMEStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinNTStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinXPStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2003Static" />  
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinVistaStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2008Static" />    
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win7Static" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2012Static" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win8Static" />

    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2KAppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win95AppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win98AppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinMEAppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinNTAppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinXPAppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2003AppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinVistaAppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2008AppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win7AppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2012AppStatic" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win8AppStatic" />

    <packageAttributeSet packageName="WindowsL2" attributeSetName="RAIDDataStatic"/>
    <packageAttributeSet packageName="WindowsL2" attributeSetName="ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win95ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win98ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinNTODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinMEODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2KODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinXPODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2003ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinVistaODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2008ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win7ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2012ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win8ODBCDriversCollection" />

    <packageAttributeSet packageName="WindowsL2" attributeSetName="RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win95RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win98RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinNTRSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinMERSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2000RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinXPRSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2003RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinVistaRSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2008RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win7RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2012RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win8RSOPPropertiesCollection" />

    <packageAttributeSet packageName="WindowsL2" attributeSetName="NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win95NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win98NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinNTNTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinMENTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2000NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinXPNTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2003NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="WinVistaNTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2008NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win7NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win2012NTPTimeServerCollection" />
    <packageAttributeSet packageName="WindowsL2" attributeSetName="Win8NTPTimeServerCollection" />

    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinTypingStatic" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2KStatic" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win95Static" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win98Static" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinMEStatic" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinNTStatic" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinXPStatic" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2003Static" />  
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinVistaStatic" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2008Static" />    
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win7Static" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2012Static" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win8Static" />

    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="RAIDDataStatic"/>
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win95ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win98ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinNTODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinMEODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2KODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinXPODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2003ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinVistaODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2008ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win7ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2012ODBCDriversCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win8ODBCDriversCollection" />

    <packageAttributeSet packageName="WindowsFileNameScanPkg" attributeSetName="WindowsFileNameScan" />


<!-- Disabling SU collection for 6.1.0 as per bug #17304
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="WinSoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win95SoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win98SoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="WinNTSoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="WinMESoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win2000SoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="WinXPSoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win2003SoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="WinVistaSoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win2008SoftwareUsage" /> 
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win7SoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win2012SoftwareUsage" />
    <packageAttributeSet packageName="WindowsSoftwareUsage" attributeSetName="Win8SoftwareUsage" />
-->

    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win95RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win98RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinNTRSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinMERSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2000RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinXPRSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2003RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="WinVistaRSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2008RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win7RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win2012RSOPPropertiesCollection" />
    <packageAttributeSet packageName="WindowsL2Sys" attributeSetName="Win8RSOPPropertiesCollection" />

    <packageAttributeSet packageName="RemoveWindowsXPProfilePkg" attributeSetName="RemoveWindowsXPProfile"/>
         
    <!-- ............................................................... -->
    <!-- .......          Windows fingerprint rules          ........... -->
    <!-- ............................................................... -->

    <!-- Creates RAIDDataCollectorFootprint -->
    <rule
        name="createRAIDDataCollectorFootprint"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <output type="root.types.footprint.RAIDDataCollectorFootprint"/>
        <output parentType="os" childType="root.types.footprint.RAIDDataCollectorFootprint" />
        <output type="root.types.footprint.RAIDDataCollectorFootprint" attribute="name" />
        <conclusion type="perl">
        <![CDATA[
            my $parent = $os{"elementFullName"};
            my $eltName = "RAIDData";
            my $eltFullName = "$parent.$eltName";

           $result = "<result>" .
                     &elementXML($eltName, "root.types.footprint.RAIDDataCollectorFootprint", $parent) .
                     &dataXML($eltFullName, "name", "Physical Disk Collection Footprint") .
                     "</result>";

        ]]>
        </conclusion>
    </rule>

    <!--  Need to be able to query a specific scan task -->
    <rule
        name="createWindowsFileScanCollectorFootprintForNetwork"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="numCPUs" />
        </search>
        <search variable="tk" pattern="root.types.internal.task">
            <use attribute="discDrive" />
            <use attribute="searchFilter" />
            <use attribute="name" />
        </search>
        <search variable="net" pattern="root.types.resource.network"/>
        <search variable="zone" pattern="root.types.collectionZone"/>
        <search variable="add" pattern="root.types.internetAddress"/>
        <search variable="host" pattern="root.types.resource.host"/>

        <search variable="fs" pattern="root.types.resource.storageAllocation.fileSystem">
            <use attribute="name" />
            <use attribute="type" />
            <use attribute="mountPoint" />
            <use attribute="capacity" />
            <use attribute="isLocal" />
        </search>
        <simpleJoinFilter lhsVariable="tk" operator="parentOf" rhsVariable="net" />
        <simpleJoinFilter lhsVariable="net" operator="parentOf" rhsVariable="zone" />
        <simpleJoinFilter lhsVariable="zone" operator="parentOf" rhsVariable="add" />
        <simpleJoinFilter lhsVariable="add" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="os" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="fs" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint"/>
        <output parentType="os" childType="root.types.footprint.WindowsFileScanCollectorFootprint" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="name" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="driveName" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="driveType" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="mountPoint" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="capacity" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="isLocal" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="taskName" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="filter" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="drive" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="splitQuery" />
        <conclusion type="perl">
        <![CDATA[
            our $result = "<result>";
            my $parent = $os{"elementFullName"};
            my $eltName = "FileScan_" . &cleanFileName($fs{"mountPoint"}. '_' . $tk{"name"});
            my $eltFullName = "$parent.$eltName";

            my $drive = substr($fs{"mountPoint"},0,1);
            my $driveSelected = 0;
            print('User disc drive selection: <' .$tk{"discDrive"}.'>, drive to be determined: <'.$fs{"mountPoint"}.'><'.$drive.">\n");
            if (!($tk{"discDrive"} =~ /\|\!\|/)) {
                my @drivesLetters = split(/\|/, $tk{"discDrive"});
                foreach my $driveLetter (@drivesLetters) {
                    if ((length($driveLetter) > 0) && ($driveLetter eq substr($fs{"mountPoint"},0,1))){
                        $driveSelected = 1;
                    }
                }
            } else {
                foreach my $driveLetter ('A' .. 'Z') {
                    if (!($tk{"discDrive"} =~ /$driveLetter/)) {
                        if ($driveLetter eq substr($fs{"mountPoint"},0,1)) {
                            $driveSelected = 1;
                        }
                    }
                }
            }

            my $splitQuery = 0;
            $splitQuery = 1 if ($parent =~ /Windows2003|Windows2000|WindowsNT/);

            if (($driveSelected) && ($fs{"isLocal"} eq 'local')) {
                $result .= &elementXML($eltName, "root.types.footprint.WindowsFileScanCollectorFootprint", $parent) .
                          &dataXML($eltFullName, "name", "Windows File Scan Footprint on " .$fs{"name"}) .
                          &dataXML($eltFullName, "taskName", $tk{"name"}) .
                          &dataXML($eltFullName, "drive", $tk{"discDrive"}) .
                          &dataXML($eltFullName, "filter", $tk{"searchFilter"}) .
                          &dataXML($eltFullName, "driveName", $fs{"name"}) .
                          &dataXML($eltFullName, "driveType", $fs{"type"}) .
                          &dataXML($eltFullName, "mountPoint", $fs{"mountPoint"}) .
                          &dataXML($eltFullName, "capacity", $fs{"capacity"}) .
                          &dataXML($eltFullName, "isLocal", $fs{"isLocal"}) .
                          &dataXML($eltFullName, "splitQuery", $splitQuery);
            }
            $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createWindowsFileScanCollectorFootprintForLogicalSetAndZone"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="numCPUs" />
        </search>
        <search variable="tk" pattern="root.types.internal.task">
            <use attribute="discDrive" />
            <use attribute="searchFilter" />
            <use attribute="name" />
        </search>
        <search variable="ls" pattern="root.types.resource.logicalset"/>
        <search variable="zone" pattern="root.types.collectionZone"/>
        <search variable="add" pattern="root.types.internetAddress"/>
        <search variable="host" pattern="root.types.resource.host"/>

        <search variable="fs" pattern="root.types.resource.storageAllocation.fileSystem">
            <use attribute="name" />
            <use attribute="type" />
            <use attribute="mountPoint" />
            <use attribute="capacity" />
            <use attribute="isLocal" />
        </search>
        <simpleJoinFilter lhsVariable="tk" operator="parentOf" rhsVariable="ls" />
        <simpleJoinFilter lhsVariable="ls" operator="parentOf" rhsVariable="zone" />
        <simpleJoinFilter lhsVariable="zone" operator="parentOf" rhsVariable="add" />
        <simpleJoinFilter lhsVariable="add" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="os" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="fs" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint"/>
        <output parentType="os" childType="root.types.footprint.WindowsFileScanCollectorFootprint" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="name" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="driveName" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="driveType" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="mountPoint" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="capacity" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="isLocal" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="taskName" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="filter" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="drive" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="splitQuery" />
        <conclusion type="perl">
        <![CDATA[
            our $result = "<result>";
            my $parent = $os{"elementFullName"};
            my $eltName = "FileScan_" . &cleanFileName($fs{"mountPoint"}. '_' . $tk{"name"});
            my $eltFullName = "$parent.$eltName";

            my $drive = substr($fs{"mountPoint"},0,1);
            my $driveSelected = 0;
            print('User disc drive selection: <' .$tk{"discDrive"}.'>, drive to be determined: <'.$fs{"mountPoint"}.'><'.$drive.">\n");
            if (!($tk{"discDrive"} =~ /\|\!\|/)) {
                my @drivesLetters = split(/\|/, $tk{"discDrive"});
                foreach my $driveLetter (@drivesLetters) {
                    if ((length($driveLetter) > 0) && ($driveLetter eq substr($fs{"mountPoint"},0,1))){
                        $driveSelected = 1;
                    }
                }
            } else {
                foreach my $driveLetter ('A' .. 'Z') {
                    if (!($tk{"discDrive"} =~ /$driveLetter/)) {
                        if ($driveLetter eq substr($fs{"mountPoint"},0,1)) {
                            $driveSelected = 1;
                        }
                    }
                }
            }

            my $splitQuery = 0;
            $splitQuery = 1 if ($parent =~ /Windows2003|Windows2000|WindowsNT/);

            if (($driveSelected) && ($fs{"isLocal"} eq 'local')) {
                $result .= &elementXML($eltName, "root.types.footprint.WindowsFileScanCollectorFootprint", $parent) .
                          &dataXML($eltFullName, "name", "Windows File Scan Footprint on " .$fs{"name"}) .
                          &dataXML($eltFullName, "taskName", $tk{"name"}) .
                          &dataXML($eltFullName, "drive", $tk{"discDrive"}) .
                          &dataXML($eltFullName, "filter", $tk{"searchFilter"}) .
                          &dataXML($eltFullName, "driveName", $fs{"name"}) .
                          &dataXML($eltFullName, "driveType", $fs{"type"}) .
                          &dataXML($eltFullName, "mountPoint", $fs{"mountPoint"}) .
                          &dataXML($eltFullName, "capacity", $fs{"capacity"}) .
                          &dataXML($eltFullName, "isLocal", $fs{"isLocal"}) .
                          &dataXML($eltFullName, "splitQuery", $splitQuery);
            }
            $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createWindowsFileScanCollectorFootprintForLogicalSetAndIP"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="numCPUs" />
        </search>
        <search variable="tk" pattern="root.types.internal.task">
            <use attribute="discDrive" />
            <use attribute="searchFilter" />
            <use attribute="name" />
        </search>
        <search variable="ls" pattern="root.types.resource.logicalset"/>
        <search variable="add" pattern="root.types.internetAddress"/>
        <search variable="host" pattern="root.types.resource.host"/>

        <search variable="fs" pattern="root.types.resource.storageAllocation.fileSystem">
            <use attribute="name" />
            <use attribute="type" />
            <use attribute="mountPoint" />
            <use attribute="capacity" />
            <use attribute="isLocal" />
        </search>
        <simpleJoinFilter lhsVariable="tk" operator="parentOf" rhsVariable="ls" />
        <simpleJoinFilter lhsVariable="ls" operator="parentOf" rhsVariable="add" />
        <simpleJoinFilter lhsVariable="add" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="os" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="fs" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint"/>
        <output parentType="os" childType="root.types.footprint.WindowsFileScanCollectorFootprint" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="name" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="driveName" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="driveType" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="mountPoint" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="capacity" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="isLocal" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="taskName" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="filter" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="drive" />
        <output type="root.types.footprint.WindowsFileScanCollectorFootprint" attribute="splitQuery" />
        <conclusion type="perl">
        <![CDATA[
            our $result = "<result>";
            my $parent = $os{"elementFullName"};
            my $eltName = "FileScan_" . &cleanFileName($fs{"mountPoint"}. '_' . $tk{"name"});
            my $eltFullName = "$parent.$eltName";

            my $drive = substr($fs{"mountPoint"},0,1);
            my $driveSelected = 0;
            print('User disc drive selection: <' .$tk{"discDrive"}.'>, drive to be determined: <'.$fs{"mountPoint"}.'><'.$drive.">\n");
            if (!($tk{"discDrive"} =~ /\|\!\|/)) {
                my @drivesLetters = split(/\|/, $tk{"discDrive"});
                foreach my $driveLetter (@drivesLetters) {
                    if ((length($driveLetter) > 0) && ($driveLetter eq substr($fs{"mountPoint"},0,1))){
                        $driveSelected = 1;
                    }
                }
            } else {
                foreach my $driveLetter ('A' .. 'Z') {
                    if (!($tk{"discDrive"} =~ /$driveLetter/)) {
                        if ($driveLetter eq substr($fs{"mountPoint"},0,1)) {
                            $driveSelected = 1;
                        }
                    }
                }
            }

            my $splitQuery = 0;
            $splitQuery = 1 if ($parent =~ /Windows2003|Windows2000|WindowsNT/);

            if (($driveSelected) && ($fs{"isLocal"} eq 'local')) {
                $result .= &elementXML($eltName, "root.types.footprint.WindowsFileScanCollectorFootprint", $parent) .
                          &dataXML($eltFullName, "name", "Windows File Scan Footprint on " .$fs{"name"}) .
                          &dataXML($eltFullName, "taskName", $tk{"name"}) .
                          &dataXML($eltFullName, "drive", $tk{"discDrive"}) .
                          &dataXML($eltFullName, "filter", $tk{"searchFilter"}) .
                          &dataXML($eltFullName, "driveName", $fs{"name"}) .
                          &dataXML($eltFullName, "driveType", $fs{"type"}) .
                          &dataXML($eltFullName, "mountPoint", $fs{"mountPoint"}) .
                          &dataXML($eltFullName, "capacity", $fs{"capacity"}) .
                          &dataXML($eltFullName, "isLocal", $fs{"isLocal"}) .
                          &dataXML($eltFullName, "splitQuery", $splitQuery);
            }
            $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createRAIDPhysicalDrive"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <search variable="fp" pattern="root.types.footprint.RAIDDataCollectorFootprint">
            <use attribute="physicalDisks" />
        </search>
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="fp" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           my $osEltFullName = $os{"elementFullName"};
           my $physicalDisks = $fp{"physicalDisks"};
           my ($elementType, $eltFullName) = ('', '');
           foreach my $oneDisk (split(/<BDNA,1>/, $physicalDisks)) {
               if ($oneDisk =~ /elementType=\"(.+?)\"<BDNA,2>/) {
                   $elementType = $1;
                   foreach my $line (split(/<BDNA,2>/, $oneDisk)) {
                       if ($line =~ /(.+?)=\"(.+)\"/) {
                           my ($propName, $propValue) = ($1, $2);
                           if ($propName eq 'elementName') {
                               $eltFullName = $osEltFullName . "." . $propValue;
                               $result .= &elementXML($propValue, "root.types.resource.storageAllocation.physicalDisk.".$elementType, $osEltFullName);
                           } else {
                               if ($propName ne 'elementType') {
                                   if ($propName =~ /(devID|name|version|manufacturer|cntlrID|model|FWVersion|serialNum|devCapacity|targetID|lunID|nexusID|productID|largestContFree|usedSpaceInMB|freeSpaceInMB|busType|state|spareState|componentStatus|rollUpStatus|smartAlert|channel|SASAddress|usedReallocs|factReallocs|hReads|reads|hWrites|writes|hSeeks|seeks|hardReadErrs|recvReadErrs|hardWriteErrs|recvWriteErrs|hSeekErrs|seekErrs|spinupTime|drqTimeouts|otherTimeouts|spinupRetries|badRecvReads|badRecvWrites|formatErrs|postErrs|notReadyErrs|reallocAborts|threshPassed|condition|hotPlugs|mediaErrs|hardwareErrs|abortedCmds|spinUpErrs|badTargetErrs|location|busFaults|irqDeglitches|hotPlug|placement|busNumber|preFailMonitoring|currentWidth|currentSpeed|failureCode|blinkTime|smartStatus|configurationStatus|rotationalSpeed|bay|status|refHours)/) {
                                   $result .= &dataXML($eltFullName, $propName, $propValue);
                                   }
                               }
                           }
                       }
                   }
               }
           }
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createRAIDLogicalDrive"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <search variable="fp" pattern="root.types.footprint.RAIDDataCollectorFootprint">
            <use attribute="logicalDisks" />
        </search>
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="fp" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           my $osEltFullName = $os{"elementFullName"};
           my $logicalDisks = $fp{"logicalDisks"};
           my ($elementType, $eltFullName) = ('', '');
           foreach my $oneDisk (split(/<BDNA,1>/, $logicalDisks)) {
               if ($oneDisk =~ /elementType=\"(.+?)\"<BDNA,2>/) {
                   $elementType = $1;
                   foreach my $line (split(/<BDNA,2>/, $oneDisk)) {
                       if ($line =~ /(.+?)=\"(.+)\"/) {
                           my ($propName, $propValue) = ($1, $2);
                           if ($propName eq 'elementName') {
                               $eltFullName = $osEltFullName . "." . $propValue;
                               $result .= &elementXML($propValue, "root.types.resource.storageAllocation.logicalDisk.".$elementType, $osEltFullName);
                           } else {
                               if ($propName ne 'elementType') {
                                   if ($propName =~ /(devID|name|version|manufacturer|cntlrID|devCapacity|phyDiskIDs|osDevName|targetID|lunID|nexusID|productID|state|severity|freeSpaceInMB|writePolicy|readPolicy|cachePolicy|layout|curStripeSizeInMB|channel|rollUpStatus|componentStatus|arrayDiskType|faultTol|status|autoRel|rebuildBlks|hasAccel|availSpares|condition|percentRebuild|stripeSize|blinkTime|spareReplaceMap|rebuildingPhyDrv)/) {
                                   $result .= &dataXML($eltFullName, $propName, $propValue);
                                   }
                               }
                           }
                       }
                   }
               }
           }
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createRAIDController"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <search variable="fp" pattern="root.types.footprint.RAIDDataCollectorFootprint">
            <use attribute="RAIDControllers" />
        </search>
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="fp" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           my $osEltFullName = $os{"elementFullName"};
           my $RAIDControllers = $fp{"RAIDControllers"};
           my ($elementType, $eltFullName) = ('', '');
           foreach my $oneCntlr (split(/<BDNA,1>/, $RAIDControllers)) {
               if ($oneCntlr =~ /elementType=\"(.+?)\"<BDNA,2>/) {
                   $elementType = $1;
                   foreach my $line (split(/<BDNA,2>/, $oneCntlr)) {
                       if ($line =~ /(.+?)=\"(.+)\"/) {
                           my ($propName, $propValue) = ($1, $2);
                           if ($propName eq 'elementName') {
                               $eltFullName = $osEltFullName . "." . $propValue;
                               $result .= &elementXML($propValue, "root.types.resource.storageAllocation.RAIDController.".$elementType, $osEltFullName);
                           } else {
                               if ($propName ne 'elementType') {
                                   if ($propName =~ /(devID|name|version|model|manufacturer|FWVersion|vendor|arrayType|clusterMode|driverVersion|state|patrolReadMode|checkConsistencyRate|reconstructRate|rebuildRateInPercent|patrolReadState|componentStatus|logicalDeviceCount|nexusID|cacheSizeInBytes|rollUpStatus|alarmState|physicalDeviceCount|patrolReadRate|channelCount|BGIRate|MinFWVersion|cacheSizeInMB|patrolReadIterations|PCISlot|slot|currentRole|productRev|redundancyError|partnerBoardStatus|condition|hwLocation|rebuildPriority|boardStatus|numberOfBuses|partnerSlot|expandPriority|blinkTime|boardCondition|accessModuleStatus|driveOwnership|partnerBoardConditiodevID|name|model|manufacturer|FWVersion|vendor|arrayType|clusterMode|driverVersion|state|patrolReadMode|checkConsistencyRate|reconstructRate|rebuildRateInPercent|patrolReadState|componentStatus|logicalDeviceCount|nexusID|cacheSizeInBytes|rollUpStatus|alarmState|physicalDeviceCount|patrolReadRate|channelCount|BGIRate|MinFWVersion|cacheSizeInMB|patrolReadIterations|PCISlot|slot|currentRole|productRev|redundancyError|partnerBoardStatus|condition|hwLocation|rebuildPriority|boardStatus|numberOfBuses|partnerSlot|expandPriority|blinkTime|boardCondition|accessModuleStatus|driveOwnership|partnerBoardCondition)/) {
                                   $result .= &dataXML($eltFullName, $propName, $propValue);
                                   }
                               }
                           }
                       }
                   }
               }
           }
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createRAIDPhyDriveContainment"
        weight="90" >
        <search variable="cntrl" pattern="root.types.resource.storageAllocation.RAIDController">
            <use attribute="devID" />
        </search>
        <search variable="drive" pattern="root.types.resource.storageAllocation.physicalDisk">
            <use attribute="cntlrID" />
        </search>
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="drive" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="cntrl" />
        <simpleJoinFilter lhsVariable="cntrl" lhsAttribute="devID" operator="equals" rhsVariable="drive" rhsAttribute="cntlrID" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           $result .= &containerXML($cntrl{"elementFullName"}, $drive{"elementFullName"});
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="createRAIDLogDriveContainment"
        weight="90" >
        <search variable="cntrl" pattern="root.types.resource.storageAllocation.RAIDController">
            <use attribute="devID" />
        </search>
        <search variable="drive" pattern="root.types.resource.storageAllocation.logicalDisk">
            <use attribute="cntlrID" />
        </search>
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="drive" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="cntrl" />
        <simpleJoinFilter lhsVariable="cntrl" lhsAttribute="devID" operator="equals" rhsVariable="drive" rhsAttribute="cntlrID" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           $result .= &containerXML($cntrl{"elementFullName"}, $drive{"elementFullName"});
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="CreateDELLPhyToLogicalDrivesContainment"
        weight="90" >
        <search variable="phy" pattern="root.types.resource.storageAllocation.physicalDisk.dell">
            <use attribute="devID" />
        </search>
        <search variable="log" pattern="root.types.resource.storageAllocation.logicalDisk.dell">
            <use attribute="phyDiskIDs" />
        </search>
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="phy" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="log" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           if ($log{"phyDiskIDs"} =~/,$phy{"devID"},/) {
               $result .= &containerXML($log{"elementFullName"}, $phy{"elementFullName"});
           }
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="CreateCompaqPhyToLogicalDrivesContainment"
        weight="90" >
        <search variable="phy" pattern="root.types.resource.storageAllocation.physicalDisk.compaq">
            <use attribute="devID" />
        </search>
        <search variable="log" pattern="root.types.resource.storageAllocation.logicalDisk.compaq">
            <use attribute="phyDiskIDs" />
        </search>
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="phy" />
        <simpleJoinFilter lhsVariable="os" operator="parentOf" rhsVariable="log" />
        <conclusion type="perl">
        <![CDATA[
           our $result = "<result>";
           if ($log{"phyDiskIDs"} =~/,$phy{"devID"},/) {
               $result .= &containerXML($log{"elementFullName"}, $phy{"elementFullName"});
           }
           $result .= "</result>";
        ]]>
        </conclusion>
    </rule>


    <!--                                                -->
    <!--        Windows computer name display           -->
    <!--                                                -->

    <rule name="RelabelWindowsOS"
          weight="99">
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="hostName" />
            <use attribute="osComputerName" />
            <use attribute="osComputerDomain" />
        </search>
        <output type="windows" attribute="name" />        
        <conclusion type="perl">
            <![CDATA[
            our %windows;
            our $result;
            my $hostName = $windows{"hostName"};
            my $osComputerDomain = $windows{"osComputerDomain"};
            my $osComputerName = $windows{"osComputerName"};

            if ( ($osComputerDomain !~ /&#/) && ($osComputerDomain !~ /%/) 
                    && ($osComputerName !~ /&#/) && ($osComputerName !~ /%/) ) {
                $result = "<result>" .
                        &dataXML($windows{"elementFullName"}, "name", "$osComputerDomain\\$osComputerName ($hostName)") .
                        "</result>";
            }
            else {
                $result = "";
            }
            ]]>
        </conclusion>
    </rule>

    <rule name="FindWindowsComputerNameAndDomainViaNBT"
          weight="94">
        <search variable="ip" pattern="root.types.internetAddress">
            <use attribute="nbtscanTrace" />
            <use attribute="address" />
        </search>
        <search variable="host" pattern="root.types.resource.host" />
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="ip" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />
        <output type="windows" attribute="osComputerName" />                
        <output type="windows" attribute="osComputerDomain" />                        
        <output type="windows" attribute="osWkgrpDomain" />
        <conclusion type="perl">
            <![CDATA[
                our (%ip, %windows, $result);
                my @lines = split(/$BDNA_Separator/, $ip{"nbtscanTrace"});
                my $ipaddr = $ip{"address"};                
                $ipaddr =~ s/^\s+//;
                $ipaddr =~ s/\s+$//;

                my ($windowsName) = grep {$_ !~ /\|IS~/ && $_ =~ /\|00U$/} @lines;
                $windowsName =~ s/^$ipaddr\|([^|]+?) *\|00U$/$1/;
                my ($windowsDomain) = grep(m/\|00G$/, @lines);
                $windowsDomain =~ s/^$ipaddr\|([^|]+?) *\|00G$/$1/;
                
                $windowsName =~ s/^\s+//;
                $windowsName =~ s/\s+$//;
                $windowsDomain =~ s/^\s+//;
                $windowsDomain =~ s/\s+$//;

                $result = "<result>";
                if ($windowsName) {
                    $windowsName = uc($windowsName);
                    $result .= &dataXML($windows{"elementFullName"}, "osComputerName", $windowsName);
                }
                if ($windowsDomain) {
                    $windowsDomain = uc($windowsDomain);
                    $result .= &dataXML($windows{"elementFullName"}, "osComputerDomain", $windowsDomain);
                    $result .= &dataXML($windows{"elementFullName"}, "osWkgrpDomain", $windowsDomain);
                }
                $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <rule name="FindWindowsComputerNameViaSMB"
          weight="95">
        <search variable="ip" pattern="root.types.internetAddress">
            <use attribute="smbServerName" />
        </search>
        <search variable="host" pattern="root.types.resource.host" />
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="ip" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />
        <output type="windows" attribute="osComputerName" />                
        <conclusion type="perl">
            <![CDATA[
                our (%ip, %windows, $result);
                $result = "<result>";
                my ($windowsName) = $ip{"smbServerName"};
                $windowsName =~ s/^\s+//;
                $windowsName =~ s/\s+$//;
                $windowsName = uc($windowsName);
                if ($windowsName ne "") {
                    $result .= &dataXML($windows{"elementFullName"}, "osComputerName", $windowsName);
                }
                $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <rule name="FindWindowsComputerDomainViaSMB"
          weight="95">
        <search variable="ip" pattern="root.types.internetAddress">
            <use attribute="smbServerDomain" />
        </search>
        <search variable="host" pattern="root.types.resource.host" />
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="ip" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />
        <output type="windows" attribute="osComputerDomain" />               
        <output type="windows" attribute="osWkgrpDomain" /> 
        <conclusion type="perl">
            <![CDATA[
                our (%ip, %windows, $result);
                $result = "<result>";
                my ($windowsDomain) = $ip{"smbServerDomain"};
                $windowsDomain =~ s/^\s+//;
                $windowsDomain =~ s/\s+$//;
                $windowsDomain = uc($windowsDomain);
                if ($windowsDomain ne "") {
                    $result .= &dataXML($windows{"elementFullName"}, "osComputerDomain", $windowsDomain);
                    $result .= &dataXML($windows{"elementFullName"}, "osWkgrpDomain", $windowsDomain);
                }
                $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <rule
        name="SynthesizeDomainMemberAttributeFromWindows"
        weight="95">
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="isDomainMember" />
        </search>
        <search variable="domain" pattern="root.types.resource.domain" />
        <search variable="ip" pattern="root.types.internetAddress" />
        <search variable="host" pattern="root.types.resource.host" />

        <simpleJoinFilter lhsVariable="domain" operator="parentOf" rhsVariable="ip" />
        <simpleJoinFilter lhsVariable="ip" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />

        <output type="root.types.resource.domain" attribute="isDomain" />
        <conclusion type="perl">
            <![CDATA[
                our %domain;
                $result = "<result>" .
                          &dataXML($domain{"elementFullName"}, "isDomain", "Yes") .
                          "</result>";
            ]]>
        </conclusion>
    </rule>


    <!--                                                -->
    <!--        Windows agent based Discovery           -->
    <!--                                                -->

    <!-- fingerprint Windows using an agent -->
    <rule
        name="FindWindowsViaAgentRule"
        weight="95" >
        <search variable="space" pattern="root.types.namespace" >
            <use attribute="name"/>
        </search>
        <search variable="agent" pattern="root.types.notifier" >
            <use attribute="namespace"/>
            <use attribute="cleReportedAddress"/>
            <use attribute="cleReportedHostName"/>
            <use attribute="osIdentification" />
            <use attribute="ipRangeMembership" />
            <use attribute="remoteReportedHostName" />
        </search>
        <simpleJoinFilter lhsVariable="space" lhsAttribute="name" operator="equals" rhsVariable="agent" rhsAttribute="namespace" />

        <output type="root.types.internetAddress" attribute="name" />
        <output type="root.types.internetAddress" attribute="address" />
        <output type="root.types.internetAddress" attribute="hostName" />
        <output type="root.types.internetAddress" attribute="NetBiosComputerName" />
        <output type="root.types.internetAddress" attribute="WindowsDomainName" />
        <output type="root.types.internetAddress" attribute="notifierOSInfo" />

        <output parentType="space" childType="root.types.internetAddress" />
        <output parentType="range" childType="root.types.internetAddress" />

        <conclusion type="perl">
            <![CDATA[
                our (%space, %agent, $result);
                my $namespace = $space{"elementFullName"};

                my $hostname = $agent{"cleReportedHostName"};
                $hostname =~ s/^\s+//;
                $hostname =~ s/\s+$//;
                # Sometimes cleReportedHostName has a trailing dot. 
                $hostname =~ s/\.$//;
                $hostname = lc($hostname);

                my $ranges = $agent{"ipRangeMembership"};
                my $ip = $agent{"cleReportedAddress"};
                $ip =~ s/^(.*):(.*)$/$1/;

                $result = "<result>";

# Creating IP element
                my $ipEltName = "internetAddress_$ip";
                $ipEltName =~ s/\./\_/g;
                my $ipEltFullName = "$namespace.$ipEltName";

                if ($hostname !~ /^[^\.]+\.[^\.]+/) {
                    $hostname = $ip;
                }
                $result .=
                    &elementXML($ipEltName, "root.types.internetAddress", $namespace) .
                    &dataXML($ipEltFullName, "name", "IP Address $ip") .
                    &dataXML($ipEltFullName, "hostName", $hostname) .
                    &dataXML($ipEltFullName, "address", $ip);
                if ($hostname !~ m/^\d+\.\d+\.\d+\.\d+$/
                    && $hostname =~ m/^[^.]+\.(.+)$/) {
                    $result .= &dataXML($ipEltFullName, "domainName", $1);
                }

                # Parse remoteReportedHostName to get NetBios name and Windows Domain Name
                # and populate into internetAddress element's NetBiosComputerName and
                # WindowsDomainName.
                  
                my $remoteComputerStr = $agent{"remoteReportedHostName"};
                my @NetBiosSamArr = split(/;/, $remoteComputerStr);
                my ($NetBiosName, $SamName, $WindowsOSComputerDomain, $SamComputerName);
                foreach (@NetBiosSamArr) {
                    if ($_ =~ /NetBiosName=(.+)/) {
                        $NetBiosName = $1;
                        $NetBiosName =~ s/^\s+//;
                        $NetBiosName =~ s/\s+$//;
                        $NetBiosName = uc($NetBiosName);
                    }
                    elsif ($_ =~ /SamName=(.+)\$$/) {
                        $SamName = $1;
                        $SamName =~ s/^\s+//;
                        $SamName = uc($SamName);
                        if ($SamName =~ /^(\S+)\\(\S+)$/) {
                            $WindowsOSComputerDomain = $1;
                            $WindowsOSComputerDomain = uc($WindowsOSComputerDomain);
                            $SamComputerName = $2;
                        }
                    }
                }  
                if (!$NetBiosName) {
                    $NetBiosName = $SamComputerName if ($SamComputerName);
                }
                $result .= &dataXML($ipEltFullName,
                                    "NetBiosComputerName",
                                    uc($NetBiosName) || $BDNA_Separator);
                $result .= &dataXML($ipEltFullName,
                                    "WindowsDomainName",
                                    uc($WindowsOSComputerDomain) || $BDNA_Separator);

                # Parse osIdentification to get os type, edition and patch level and 
                # format these information into a parsable string and
                # stash it into internetAddress element's notifierOSInfo.

                my $osInfo = $agent{"osIdentification"};        
                my $osInfoStr;
                if ($osInfo =~ /Windows 95/) {
                    $osInfoStr = 'Windows95';
                }
                elsif ($osInfo =~ /Windows 98/) {
                    $osInfoStr = 'Windows98';
                }
                elsif ($osInfo =~ /Windows Me/) {
                    $osInfoStr = 'WindowsME';
                }
                elsif ($osInfo =~ /Windows NT/) {
                    $osInfoStr = 'WindowsNT';
                }
                elsif ($osInfo =~ /Windows 2000/) {
                    $osInfoStr = 'Windows2000';
                }
                elsif ($osInfo =~ /Windows XP/) {
                    $osInfoStr = 'WindowsXP';
                }
                elsif ($osInfo =~ /Windows Server 2003/) {
                    $osInfoStr = 'Windows2003';
                }
                elsif ($osInfo =~ /Windows.*Vista/) {
                    $osInfoStr = 'WindowsVista';
                }
                elsif ($osInfo =~ /Windows.*Starter 2007/) {
                    $osInfoStr = 'WindowsVista';
                }
                #TBD: Add windows 2008
                $osInfoStr .= ';';
                if ($osInfo =~ /(Service Pack\s+\d+)/) {
                    $osInfoStr .= $1;
                }                
                $osInfoStr .= ';';
                if ($osInfo =~ /Windows NT (Workstation|Server|Enterprise Server)/) {
                    $osInfoStr .= "$1";
                }
                elsif ($osInfo =~ /Windows 2000 (Professional|Server|Advanced Server|Datacenter Server)/) {
                    $osInfoStr .= "$1";
                }
                elsif ($osInfo =~ /Windows XP (Home|Professional|Media Center|Tablet PC|64-Bit)/) {
                    $osInfoStr .= "$1";
                }
                elsif ($osInfo =~ /Windows Server 2003/) {
                    $osInfoStr .= 'Server';
                }
                elsif ($osInfo =~ /Windows.*Vista.*(Business N |Business|Enterprise|Home Basic N |Home Basic|Home Premium|Ultimate)/) {
                    $osInfoStr .= "$1";
                }
                elsif ($osInfo =~ /Windows.*Starter 2007/) {
                    $osInfoStr .= 'Starter';
                }
                $osInfoStr .= ';';
                $osInfoStr .= "$NetBiosName" if ($NetBiosName);
                $osInfoStr .= ';';
                $osInfoStr .= "$WindowsOSComputerDomain" if ($WindowsOSComputerDomain);
                $osInfoStr .= ';';                            
                $result .= &dataXML($ipEltFullName, "notifierOSInfo", $osInfoStr) if ($osInfoStr);
                
# add the containment links between the IP range and the IP
                my @r = split(/$BDNA_Separator/, $ranges);
                foreach my $range (@r) {
                    $result .= &containerXML($range, $ipEltFullName);
                }

                $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <!-- =============================================== -->
    <!--                                                 -->
    <!-- Windows WMI-based level-2 system data discovery -->
    <!--                                                 -->
    <!-- =============================================== -->

<!-- Disable NoCred credentials to disallow this type of collection see bug# 8959    
    <collector
        collectorName="WinStaticNoCredCollector"
        weight="210"
        connectionMethodPath="root.types.collection.connectionMethod.windowsNoCred"
        collectionScriptName="WinStaticNoCredScript">
    </collector>
-->    

    <collector
        collectorName="WinStaticDomainCheckCollector"
        weight="210"
        connectionMethodPath="root.types.collection.connectionMethod.perl.localHostConnection"
        collectionScriptName="WinStaticDomainCheckScript">
    </collector>

    <collector
        collectorName="WinTypingStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinTypingStaticScript">
    </collector>
    <collector
        collectorName="RAIDDataStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.perl.snmp"
        collectionScriptName="RAIDDataStaticScript">
        <collectionParams typeElementFullName="root.types.internetAddress" attributeName="address" />
    </collector>

    <collector
        collectorName="Win95StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win95AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>


    <collector
        collectorName="Win98StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win98AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>


    <collector
        collectorName="WinMEStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="WinMEAppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="WinNTStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="WinNTAppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="Win2KStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win2KAppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="WinXPStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="WinXPAppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="Win2003StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win2003AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="WinVistaStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="WinVistaAppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="Win2008StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win2008AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="Win7StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win7AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="Win2012StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win2012AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="Win8StaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinStaticScript">
    </collector>

    <collector
        collectorName="Win8AppStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinAppStaticScript">
    </collector>

    <collector
        collectorName="WindowsFileNameScanStaticCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="WinFileSearchScript">
    </collector>

<!-- Disabling SU collection for 6.1.0 as per bug #17304
    <collector
        collectorName="WinSoftwareUsageCollector"
        weight="220"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="SoftwareUsageScript">
        <scriptRef name="ConnWincsRemoteExecScript" scriptType="connectionOverride" seqNum="1" />
    </collector>
-->

    <collector
        collectorName="RemoveWindowsXPProfileCollector"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="RemoveWindowsProfileScript">
    </collector>
    
    <collector
        collectorName="ODBCDriversCollector"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="ODBCDriversCollectionScript">
    </collector>

    <collector
        collectorName="RSOPPropertiesCollector"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="RSOPPropertiesScript">
        <scriptRef name="ConnWincsRemoteExecScript" scriptType="connectionOverride" seqNum="1" />
    </collector>

    <collector
        collectorName="NTPTimeServerCollector"
        connectionMethodPath="root.types.collection.connectionMethod.windows"
        collectionScriptName="NTPTimeServerCollectionScript">
        <scriptRef name="ConnWincsRemoteExecScript" scriptType="connectionOverride" seqNum="1" />
        <collectionParams typeElementFullName="root.types.resource.software.operatingSystem.Windows" attributeName="ntpW32tmCmd" />
    </collector>
    
    <!-- Re-type generic Windows element to specific sub-type using level-2 data -->

    <rule name="retypeWindowsToSubTypeUsingSystemData"
          weight="95">
        <search variable="host" pattern="root.types.resource.host">
            <use attribute="hostName" />
            <use attribute="name" />
        </search>
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" sticky="true">
            <!--
                Regarding the combination of <search ... sticky=true>
                and <use ... sticky=false>: This rule's firing should
                not retract just because the generic Windows element
                is deactivated/dedupped or retracted (either would
                result in active=0), but the firing should be
                retracted if the *data* that supports the conclusion
                were to be retracted.
            -->
            <use attribute="hostName" sticky="false" />
            <use attribute="identificationMethod" sticky="false" />
            <use attribute="systemData" sticky="false" />
        </search>
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />
        <simpleJoinFilter lhsVariable="host" lhsAttribute="hostName" operator="equals" rhsVariable="windows" rhsAttribute="hostName" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="name" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="hostName" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="identificationMethod" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="identificationConfidence" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="originalConfidence" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="deviceType" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="idString" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="scanDate" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="level1AccessOK" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="level2AccessOK" />
        <output includeSubtype="true" parentType="host" childType="root.types.resource.software.operatingSystem.Windows" />                              
        <conclusion type="perl">
            <![CDATA[
            our (%host, %windows, $result);
            my ($idString, $type, $eltName);
            my @lines = split(m/$BDNA_Separator/, $windows{"systemData"});
            $result = "<result>";
            foreach my $line (@lines) {
                if ($line =~ m/^operatingSystem\.idString=\s*(.*?)\s*$/) {
                    $idString = $1;

                    if ($idString =~ m/Windows 95/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows95";
                        $eltName = "Windows95";
                    } elsif ($idString =~ m/Windows 98/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows98";
                        $eltName = "Windows98";
                    } elsif ($idString =~ m/Windows Me/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.WindowsME";
                        $eltName = "WindowsME";
                    } elsif ($idString =~ m/Windows NT/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.WindowsNT";
                        $eltName = "WindowsNT";
                    } elsif ($idString =~ m/Windows 2000/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2000";
                        $eltName = "Windows2000";
                    } elsif ($idString =~ m/Windows XP/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.WindowsXP";
                        $eltName = "WindowsXP";
                    } elsif ($idString =~ m/Windows\(R\) Server 2003/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2003";
                        $eltName = "Windows2003";
                    } elsif ($idString =~ m/Windows.*Vista/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.WindowsVista";
                        $eltName = "WindowsVista";
                    } elsif ($idString =~ m/Windows.*Starter 2007/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.WindowsVista";
                        $eltName = "WindowsVista";
                    } elsif ($idString =~ m/Windows.*Server.*Longhorn/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2008";
                        $eltName = "Windows2008";                
                    } elsif ($idString =~ m/Windows.*Server.*2008/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2008";
                        $eltName = "Windows2008";                
                    } elsif ($idString =~ m/Windows 7/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows7";
                        $eltName = "Windows7";
                    } elsif ($idString =~ m/Windows 2012/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2012";
                        $eltName = "Windows2012";
                    } elsif ($idString =~ m/Windows 8/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows8";
                        $eltName = "Windows8";
                    } else {
                        $type = "";
                        $eltName = "";
                    }
                }
            }
            if ($eltName ne "") {
                my $eltFullName = $host{"elementFullName"} . "." . $eltName;
                $result .= &elementXML($eltName, $type, $host{"elementFullName"}) .
                    &dataXML($eltFullName, "name", $host{"name"}) .
                    &dataXML($eltFullName, "hostName", $host{"hostName"}) .
                    &dataXML($eltFullName, "identificationMethod", "Level-2 Discovery Data") .
                    &dataXML($eltFullName, "identificationConfidence", "95") .
                    &dataXML($eltFullName, "originalConfidence", "95") .
                    &dataXML($eltFullName, "deviceType", "device.system") .
                    &dataXML($eltFullName, "scanDate", &to_bdna_date(scalar(localtime()))) .
                    &dataXML($eltFullName, "level1AccessOK", "1") .
                    &dataXML($eltFullName, "level2AccessOK", "1") .
                    &dataXML($eltFullName, "idString", $idString);
            }
            $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <!-- Re-type generic Windows element to specific sub-type using level-2 data -->

    <rule name="retypeWindowsToSubTypeUsingLevel2Data"
          weight="95">
        <search variable="host" pattern="root.types.resource.host">
            <use attribute="hostName" />
            <use attribute="name" />
        </search>
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" sticky="true">
            <!--
                Regarding the combination of <search ... sticky=true>
                and <use ... sticky=false>: This rule's firing should
                not retract just because the generic Windows element
                is deactivated/dedupped or retracted (either would
                result in active=0), but the firing should be
                retracted if the *data* that supports the conclusion
                were to be retracted.
            -->
            <use attribute="hostName" sticky="false" />
            <use attribute="identificationMethod" sticky="false" />
            <use attribute="windowsTypingData" sticky="false" />
        </search>
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />
        <simpleJoinFilter lhsVariable="host" lhsAttribute="hostName" operator="equals" rhsVariable="windows" rhsAttribute="hostName" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="name" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="hostName" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="identificationMethod" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="identificationConfidence" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="originalConfidence" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="deviceType" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="idString" />  
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="scanDate" />                         
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="level1AccessOK" />
        <output includeSubtype="true" type="root.types.resource.software.operatingSystem.Windows" attribute="level2AccessOK" />
        <output includeSubtype="true" parentType="host" childType="root.types.resource.software.operatingSystem.Windows" />                              
        <conclusion type="perl">
            <![CDATA[
            our (%host, %windows, $result);
            my ($idString, $type, $eltName);
            $result = "<result>";
            if ( $windows{"windowsTypingData"} =~  m/^operatingSystem\.idString=\s*(.*?)\s*$/) {
                $idString = $1;
                if ($idString =~ m/Windows 95/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.Windows95";
                    $eltName = "Windows95";
                } elsif ($idString =~ m/Windows 98/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.Windows98";
                    $eltName = "Windows98";
                } elsif ($idString =~ m/Windows Me/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.WindowsME";
                    $eltName = "WindowsME";
                } elsif ($idString =~ m/Windows NT/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.WindowsNT";
                    $eltName = "WindowsNT";
                } elsif ($idString =~ m/Windows 2000/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.Windows2000";
                    $eltName = "Windows2000";
                } elsif ($idString =~ m/Windows XP/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.WindowsXP";
                    $eltName = "WindowsXP";
                } elsif ($idString =~ m/Windows\(R\) Server 2003/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.Windows2003";
                    $eltName = "Windows2003";
                } elsif ($idString =~ m/Windows.*Vista/) {
                    $type = "root.types.resource.software.operatingSystem.Windows.WindowsVista";
                    $eltName = "WindowsVista";
                } elsif ($idString =~ m/Windows.*Starter 2007/) {
                        $type = "root.types.resource.software.operatingSystem.Windows.WindowsVista";
                        $eltName = "WindowsVista";
                } elsif ($idString =~ m/Windows.*Server.*Longhorn/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2008";
                        $eltName = "Windows2008";                
                } elsif ($idString =~ m/Windows.*Server.*2008/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2008";
                        $eltName = "Windows2008";                
                } elsif ($idString =~ m/Windows 7/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows7";
                        $eltName = "Windows7";
                } elsif ($idString =~ m/Windows.*Server.*2012/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows2012";
                        $eltName = "Windows2012";
                } elsif ($idString =~ m/Windows 8/){
                        $type = "root.types.resource.software.operatingSystem.Windows.Windows8";
                        $eltName = "Windows8";
                } else {
                    $type = "";
                    $eltName = "";
                }
            }
            if ($eltName ne "") {
                my $eltFullName = $host{"elementFullName"} . "." . $eltName;
                $result .= &elementXML($eltName, $type, $host{"elementFullName"}) .
                    &dataXML($eltFullName, "name", $host{"name"}) .
                    &dataXML($eltFullName, "hostName", $host{"hostName"}) .
                    &dataXML($eltFullName, "identificationMethod", "Level-2 Discovery Data") .
                    &dataXML($eltFullName, "identificationConfidence", "95") .
                    &dataXML($eltFullName, "originalConfidence", "95") .
                    &dataXML($eltFullName, "deviceType", "device.system") .
                    &dataXML($eltFullName, "scanDate", &to_bdna_date(scalar(localtime()))) .
                    &dataXML($eltFullName, "level1AccessOK", "1") .
                    &dataXML($eltFullName, "level2AccessOK", "1") .
                    &dataXML($eltFullName, "idString", $idString);
            }
            $result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <!-- Use SMB data to determine Windows edition -->

    <rule
        name="FindWindowsEditionFromSMB"
        weight="91">
        <search variable="ip" pattern="root.types.internetAddress">
            <use attribute="smbServerOSType" />
        </search>
        <search variable="host" pattern="root.types.resource.host" />
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" />
        <simpleJoinFilter lhsVariable="ip" operator="parentOf" rhsVariable="host" />
        <simpleJoinFilter lhsVariable="host" operator="parentOf" rhsVariable="windows" />
        <output type="windows" attribute="edition" />
        <conclusion type="perl">
        <![CDATA[
            our (%ip, %windows);
            $result = "<result>";
            if ($ip{"smbServerOSType"} =~ m/\[.+\]/) {
                # SMB reported *something* for us to work from....
                my $isServer;
                my @markers = ('[SERVER_NT]', '[DOMAIN_CTRL]', '[DOMAIN_BAKCTRL]');
                foreach my $marker (@markers) {
                    if ($ip{"smbServerOSType"} =~ m/\Q$marker\E/) {
                        $isServer = 1;
                        last;
                    }
                }
                my $nonServer;
                if ($windows{"elementFullName"} =~ m/\.WindowsNT$/) {
                    $nonServer = "Workstation";
                } elsif ($windows{"elementFullName"} =~ m/\.Windows2000$/) {
                    $nonServer = "Professional";
                } elsif ($windows{"elementFullName"} =~ m/\.WindowsXP$/) {
                    $nonServer = "Home or Professional";
                } elsif ($windows{"elementFullName"} =~ m/\.Windows2003$/) {
                    # Every install of Windows 2003 is a server edition....
                    $nonServer = "Server or higher";
                } elsif ( ($windows{"elementFullName"} =~ m/\.WindowsVista$/) && ($ip{"smbServerOSType"} =~ m/Windows.*Vista.*(Business N |Business|Enterprise|Home Basic N |Home Basic|Home Premium|Ultimate)/) ) {
                    $nonServer = "$1";
                } elsif ( ($windows{"elementFullName"} =~ m/\.WindowsVista$/) && ($ip{"smbServerOSType"} =~ m/Windows.*Starter 2007/) ) {
                    $nonServer = "Starter";
                } elsif ( ($windows{"elementFullName"} =~ m/\.Windows2008$/) && ($ip{"smbServerOSType"} =~ m/Windows.*Server.*2008.*(Standard|Enterprise)/) ) {
                    $nonServer = $1;
                } elsif ($windows{"elementFullName"} =~ m/\.Windows2008$/) {
                    $nonServer = "Server or higher";
                } elsif ( ($windows{"elementFullName"} =~ m/\.Windows7$/) && ($ip{"smbServerOSType"} =~ m/Windows 7.*(Enterprise|Professional|Home Basic|Home Basic|Home Premium|Ultimate|Starter)/) ) {
                    $nonServer = "$1";
                } else {
                    $nonServer = "Non-server edition";
                }
                $result .= &dataXML($windows{"elementFullName"},
                                    "edition",
                                    ($isServer ? "Server or higher" : $nonServer));
            } elsif ($ip{"smbServerOSType"} =~ m/\{.+\}/) {
                # SMB reported *something* useful in "{***}" for us to work from....
                my $edition;
                if ( ($windows{"elementFullName"} =~ m/\.Windows7$/) && ($ip{"smbServerOSType"} =~ m/Windows 7.*(Enterprise|Professional|Home Basic|Home Basic|Home Premium|Ultimate|Starter)/) ) {
                    $edition = $1;
                }
                if ($edition) {
                    $result .= &dataXML($windows{"elementFullName"},
                                        "edition",
                                        $edition);
                }
            } else {
                # SMB reported *nothing* for us to work from....
                if ($windows{"elementFullName"} =~ m/\.Windows200[38]$/) {
                    # Every install of Windows 2003 is a server edition....Assuming same for 2008
                    $result .= &dataXML($windows{"elementFullName"},
                                        "edition",
                                        "Server or higher");
                } else {
                    $result .= &dataXML($windows{"elementFullName"},
                                        "edition",
                                        "Unknown");
                }
            }
            $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <!-- Find Windows Hotfix Information -->
    <rule
        name="findHotfixFromPatches"
        weight="96"
        isTrigger="true">
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="patches" />
        </search>
        <output type="windows" attribute="patchesInstalled" />
        <conclusion type="perl">
        <![CDATA[
        our %windows;
        our $result = "<result>";

        my $eltFullName = $windows{"elementFullName"};
        my $patchesInstalled = $windows{"patches"};
        $patchesInstalled =~ s/$BDNA_Sub2Separator/$BDNA_Separator/g;
        $result .= &dataXML($eltFullName, "patchesInstalled", $patchesInstalled);
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>


    <!-- Find Windows Information -->
    <rule
        name="findInstalledSoftwareFromInstalledSoftwareDetails"
        weight="96"
        isTrigger="true">
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="installedSoftwareDetails" />
        </search>
        <output type="windows" attribute="installedSoftware" />
        <conclusion type="perl">
        <![CDATA[
        our %windows;
        our $result = "<result>";

        my $eltFullName = $windows{"elementFullName"};
        my $installedSoftwareDetails = $windows{"installedSoftwareDetails"};

        my (@patches, @displayNames);

        foreach my $installedSoftware (split(/$BDNA_SubSeparator/, $installedSoftwareDetails)) {

            my @details = split(/$BDNA_Sub2Separator/, $installedSoftware);
            my ($displayName, $subKeyLabel);
               while (@details) {
                   my ($key, $value);
                   $key = shift(@details);
                   $value = shift(@details);
                   if ($key =~ m/SubKeyLabel/) {
                       $subKeyLabel = $value;
                       chomp($subKeyLabel);
                   }
                   elsif ($key =~ m/DisplayName/) {
                       $displayName = $value;
                       chomp($displayName);
                   }
               }
               if ($subKeyLabel !~ m/^\s*$/) {
                   if ($displayName !~ m/^\s*$/) {
                       push (@displayNames, $displayName);
                   } else {
                       push (@displayNames, $subKeyLabel);
                   }
               }
           }
           @displayNames = sort @displayNames;
           $result .= &dataXML($eltFullName, "installedSoftware", join($BDNA_Separator, @displayNames));
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <rule
        name="findWindowsOSDataFromSystemData"
        weight="96"
        isTrigger="true">
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows">
            <use attribute="systemData" />
        </search>

        <output type="windows" attribute="CPUUtilPercent" />
        <output type="windows" attribute="edition" />
        <output type="windows" attribute="groups" />
        <output type="windows" attribute="hardware" />
        <output type="windows" attribute="licenseKey" />
        <output type="windows" attribute="appProductID" />
        <output type="windows" attribute="appLicenseType" />
        <!-- <output type="windows" attribute="powerSettingsDetails" /> -->
        <output type="windows" attribute="services" />
        <output type="windows" attribute="numServices" />
        <output type="windows" attribute="monitors" />
        <output type="windows" attribute="numMonitors" />
        <output type="windows" attribute="osLanguage" />
        <output type="windows" attribute="serviceRelease" />
        <output type="windows" attribute="memoryUtilPercent" />
        <output type="windows" attribute="numUsers" />
        <output type="windows" attribute="osComputerDomain" />
        <output type="windows" attribute="osComputerName" />
        <output type="windows" attribute="patchLevel" />
        <output type="windows" attribute="winProcesses" />
        <output type="windows" attribute="winShare" />
        <output type="windows" attribute="userInfo" />
        <output type="windows" attribute="numProcesses" />
        <output type="windows" attribute="serialNumber" />
        <output type="windows" attribute="swapSpace" />
        <output type="windows" attribute="totalMemory" />
        <output type="windows" attribute="upTime" />
        <output type="windows" attribute="users" />
        <output type="windows" attribute="version" />
        <output type="windows" attribute="productType" />
        <output type="windows" attribute="lastLogon" />
        <output type="windows" attribute="hwIdentNum"/>
        <output type="windows" attribute="hwUUID" />
        <output type="windows" attribute="bdnaUniqueID" />
        <output type="windows" attribute="osBitMode" />
        <output type="windows" attribute="biosReleaseDate" />
        <output type="windows" attribute="biosVersion" />
        <output type="windows" attribute="level2AccessOK" />
        <output type="windows" attribute="scanDate" />
        <output type="windows" attribute="terminalServerUDT" />

        <conclusion type="perl">
        <![CDATA[
        our %windows;

        my $eltFullName = $windows{"elementFullName"};
        $windows{"systemData"} =~ s/(\r|\n)//g;
        my @lines = split(/$BDNA_Separator/, $windows{"systemData"});

        my ($uptime1, $uptime2, @users, @groups, @processes, $hw_model,
            $hw_manufacturer, $hardware_ManufacModel, $biosSerialNumber,
            $productIdentifyingNumber, $enclosureSerialNumber, $productUUID, $serviceRelease,
            $idString, $osArchitecture, $biosBIOSVersion, $biosVersion, $osLanguage,
            $osComputerDomain, $edition, $installDate, $appProductID);

        my $patchLevel = 'No Service Pack found';

        my ($name, $AllowTSConnections, $LicensingName, $LicensingType, $Logons, $TerminalServerMode, $Status, $Components);
        our $result = "<result>";

        foreach my $line (@lines) {
            if ($line =~ /operatingSystem\.uptime1=(\d+)/) {
                $uptime1 = $1;
            }
            elsif ($line =~ /operatingSystem\.uptime2=(\d+)/) {
                $uptime2 = $1;
            }
            elsif ($line =~ /operatingSystem\.version=(.+)/) {
                $result .= &dataXML($eltFullName, "version", $1);
            }
            elsif ($line =~ /operatingSystem\.productType=(.+)/) {
                $result .= &dataXML($eltFullName, "productType", $1);
            } 
            elsif ($line =~ /operatingSystem\.licenseKey=(.+)/) {
                $result .= &dataXML($eltFullName, "licenseKey", $1);
            }   
            elsif (($line =~ /operatingSystem\.domain=(.+)/) ||
                   ($line =~ /host\.domain=(.+)/)) {
                $osComputerDomain = uc($1) if (!$osComputerDomain);
            }
            elsif ($line=~ /operatingSystem\.installDate=(.+)/) {
                $installDate = $1;
            }
            elsif ($line =~ /host\.dwmembership=(.+)/) {
                if( $1 =~ /^[^(0|2)]/ ){
                    $result .= &dataXML($eltFullName, "isDomainMember", "Yes");
                }
            }
            elsif ($line =~ /operatingSystem\.appProductID=(.+)/) {
                $appProductID = $1;
                $result .= &dataXML($eltFullName, "appProductID", $1);
            }   
            elsif ($line =~ /operatingSystem\.lastLogon=(.+)/) {
                my $lastLogon = $1;

                if ($lastLogon =~ /^\\(.+@.+)/) {
                    $lastLogon = $1;
                } elsif ($lastLogon =~ /(.+)\\(.+)@(.+)/) {
                    if ($1 eq $3) {
                        $lastLogon = $2.'@'.$1;
                    }
                }
                $result .= &dataXML($eltFullName, "lastLogon", $lastLogon);
            }
            elsif ($line =~ /operatingSystem\.numUsers=(\d+)/) {
                $result .= &dataXML($eltFullName, "numUsers", $1);
            }
            elsif ($line =~ /operatingSystem\.swapSpace=(\d+)/) {
                $result .= &dataXML($eltFullName, "swapSpace", $1);
            }
            elsif ($line =~ /operatingSystem\.patchLevel=(.*)/) {
               if ($1 =~ /(.+)/) {
                  $patchLevel = $1;
                  if ($patchLevel =~ /(.+?)\,.*/) {
                      $patchLevel = $1;
                  }
               }
            }
            elsif ($line =~ /operatingSystem\.idString=(.+)/){
                $idString = $1;
                if ($idString =~ /Microsoft Windows NT (Workstation|Server|Enterprise Server)\(\d+\)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft Windows 2000 (Professional|Server|Advanced Server|Datacenter Server)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft Windows XP (Home|Professional|Professionnel|Media Center|Tablet PC|64-Bit)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft\(R\) Windows\(R\) XP (Home|Professional|Professionnel|Media Center|Tablet PC|64-Bit)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft\(R\) Windows\(R\) Server 2003, (\S+) Edition/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft\(R\) Windows\(R\) Server 2003 (\S+) x64 Edition/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft\(R\) Windows\(R\) Server 2003 for ([^(]+ Server)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft.*Windows.*Vista.*(Business N |Business|Enterprise|Home Basic N |Home Basic|Home Premium|Ultimate)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft.*Windows.*Starter 2007/) {
                  $edition = 'Starter';
                }
                elsif ($idString =~ /Microsoft.*Windows.*Server.*2008.*(Standard|Enterprise)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft Windows Web Server 2008/) {
                  $edition = 'Web';
                }
                elsif ($idString =~ /Windows 7.*(Enterprise|Professional|Home Basic|Home Premium|Ultimate|Starter)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft Windows 8 (Enterprise)\(.*\)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft Windows 8 (Enterprise N)\(.*\)/) {
                  $edition = $1;
                }
                elsif ($idString =~ /Microsoft Windows 8 Pro/) {
                  $edition = 'Professional';
                }
                elsif ($idString =~ /Microsoft Windows 8 Pro N/) {
                  $edition = 'Professional N';
                }
                elsif ($idString =~ /Microsoft Windows 8\(.*\)/) {
                  $edition = 'Standard';
                }
                elsif ($idString =~ /Microsoft Windows 8 N\(.*\)/) {
                  $edition = 'Standard N';
                }
                elsif ($idString =~ /Microsoft.*Windows.*Server.*2012.*(Datacenter|Standard|Essentials|Foundation)\(.*\)/) {
                  $edition = $1;
                }
            }
            elsif ($line =~ /hardware\.model=(.+)/) {
                $hw_model = $1;
            }
            elsif ($line =~ /hardware\.manufacturer=(.+)/) {
                $hw_manufacturer = $1;
            }
            elsif ($line =~ /hardware\.totalMemory=(\d+)/) {
                $result .= &dataXML($eltFullName, "totalMemory", $1);
            }
            elsif ($line =~ /hardware\.memoryUtilPercent=(\d+)/) {
                $result .= &dataXML($eltFullName, "memoryUtilPercent", $1);
            }
            #elsif ($line =~ /hardware\.numCPUs=(\d+)/) {
            #    $result .= &dataXML($eltFullName, "numCPUs", $1) ;
            #}
            elsif ($line =~ /hardware\.CPUUtilPercent=(\d+)/) {
                $result .= &dataXML($eltFullName, "CPUUtilPercent", $1);
            }
            elsif ($line =~ /host\.hostName=(\S+)/) {
                $result .= &dataXML($eltFullName, "osComputerName", uc($1));
            }
            elsif ($line =~ /hardware\.serialNumber=(.+)/) {
                $biosSerialNumber = $1;
            }
            elsif ($line =~ /hardware\.UUID=(.+)/) {
                $productUUID = $1 if ($1 !~ /^\s+$/);
            }
            elsif ($line =~ /hardware\.identifyingNumber=(.+)/) {
                $productIdentifyingNumber = $1 if ($1 !~ /^\s+$/);
            }
            elsif ($line =~ /hardware\.systemEnclosureSerialNumber=(.+)/) {
                $enclosureSerialNumber = $1 if ($1 !~ /^\s+$/);
            }
            elsif ($line =~ /hardware\.SMBIOSAssetTag=(.+)/) {
                my $smbiosAssetTag = $1;
                $smbiosAssetTag =~ s/^\s+//;
                $smbiosAssetTag =~ s/\s+$//;
                $result .= &dataXML($eltFullName, "SMBIOSAssetTag", $smbiosAssetTag) if ($smbiosAssetTag);
            }
            elsif ($line =~ /operatingSystem\.users[\d]+=(.+)/) {
                push(@users, $1);
            }
            elsif ($line =~ /operatingSystem\.groups[\d]+=(.+)/) {
                push(@groups, $1);
            }
            elsif ($line =~ /operatingSystem\.winProcesses=(.+)/) {
                my $processesString = $1;
                $result .= &dataXML($eltFullName, "winProcesses", $processesString);

                $processesString =~ s/^<BDNA,1>(.+)/$1/;
                my @processesArray = split(/$BDNA_SubSeparator/, $processesString);
                $result .= &dataXML($eltFullName, "numProcesses", scalar(@processesArray));
            }
            elsif ($line =~ /operatingSystem\.shareInfo=(.+)/) {
                my $shareString = $1;
                $shareString =~ s/<BDNA,1>/<BDNA,>/g;
                $shareString =~ s/<BDNA,2>/<BDNA,1>/g;
                $result .= &dataXML($eltFullName, "winShare", $shareString);
            }
            elsif ($line =~ /operatingSystem\.userInfo=(.+)/) {
                my $userString = $1;
                $userString =~ s/<BDNA,1>/<BDNA,>/g;
                $userString =~ s/<BDNA,2>/<BDNA,1>/g;
                $result .= &dataXML($eltFullName, "userInfo", $userString);
            }
            elsif ($line =~ /operatingSystem\.buildNumber=(.+)/) {
                $result .= &dataXML($eltFullName, "osBuildNumber", $1);
            }
            elsif ($line =~ /BDNA\.GUID=(\S+)/) {
                $result .= &dataXML($eltFullName, "bdnaUniqueID", $1);
            }
            elsif ($line =~ /operatingSystem\.services=(.+)/) {
                my $servicesString = $1;
                $result .= &dataXML($eltFullName, "services", $servicesString);

                $servicesString =~ s/^<BDNA,1>(.+)/$1/;
                my @servicesArray = split(/$BDNA_SubSeparator/, $servicesString);
                $result .= &dataXML($eltFullName, "numServices", scalar(@servicesArray));
            }
           elsif ($line =~ /operatingSystem\.monitors=(.+)/) {
                my $monitorString = $1;
                $result .= &dataXML($eltFullName, "monitors", $monitorString);

                $monitorString =~ s/^<BDNA,1>(.+)/$1/;
                my @monitorArray = split(/$BDNA_SubSeparator/, $monitorString);
                $result .= &dataXML($eltFullName, "numMonitors", scalar(@monitorArray));
            }
            ## Bug 17320 
            #elsif ($line =~ /operatingSystem\.powerSettingsDetails=(.+)/){
            #    $result .= &dataXML($eltFullName, "powerSettingsDetails", $1);
            #}
            elsif ($line =~ /operatingSystem\.osArchitecture=(.+)/){
                $osArchitecture = $1;
            }
            elsif ($line =~ /operatingSystem\.osLanguage=(.+)/){
                $osLanguage = $1;
                $result .= &dataXML($eltFullName, "osLanguage", $osLanguage);
            }
            elsif ($line =~ /operatingSystem\.serviceRelease=(.+)/){
                $serviceRelease = $1;
                $result .= &dataXML($eltFullName, "serviceRelease", $serviceRelease);
            }
            elsif ($line =~ /bios\.ReleaseDate=(\d\d\d\d)(\d\d)(\d\d)/){
                $result .= &dataXML($eltFullName, "biosReleaseDate", "$1-$2-$3");
            }
            elsif ($line =~ /bios\.BiosVersion=(.+)/){
                $biosBIOSVersion = $1;
            }
            elsif ($line =~ /bios\.Version=(.+)/){
                $biosVersion = $1;
            }
            if ($line =~ /ts\.TerminalServerMode=(.*)/) {
                $name = "Windows Terminal Server";
                $TerminalServerMode = $1;
            }
            if ($line =~ /ts\.LicensingName=(.+)/) {$LicensingName = $1;}
            if ($line =~ /ts\.LicensingType=(.+)/) {$LicensingType = $1;}
            if ($line =~ /ts\.Logons=(.+)/) {$Logons = $1;}
            if ($line =~ /ts\.AllowTSConnections=(.+)/) {$AllowTSConnections = $1;}
            if ($line =~ /ts\.Status=(.+)/) {$Status = $1;}
            if ($name) {
                $Components = "Name=" . $name . "<BDNA,1>AllowTSConnections=" . $AllowTSConnections . "<BDNA,1>Logons=" . $Logons . "<BDNA,1>LicensingName=" . $LicensingName . "<BDNA,1>LicensingType=" . $LicensingType . "<BDNA,1>TerminalServerMode=" . $TerminalServerMode . "<BDNA,1>Status=" . $Status;
            }
        }
        if ($Components) {
            $result .= &dataXML($eltFullName, "terminalServerUDT", $Components);
        }
        if ($biosBIOSVersion) {
            $result .= &dataXML($eltFullName, "biosVersion", $biosBIOSVersion);
        } elsif ($biosVersion) {
            $result .= &dataXML($eltFullName, "biosVersion", $biosVersion);
        }

        if (defined($osArchitecture) && ($osArchitecture =~ /64-bit/)) {
            $result .= &dataXML($eltFullName, "osBitMode", 64);
            $edition .= " (64-bit)" if (($edition) && ($edition !~ /64/));
        } elsif (defined($osArchitecture) && ($osArchitecture =~ /32-bit/)) {
            $result .= &dataXML($eltFullName, "osBitMode", 32);
        } else {
            if (defined($idString) && ($idString =~ /\bx64\b/)) {
                $result .= &dataXML($eltFullName, "osBitMode", 64);
                $edition .= " (64-bit)" if (($edition) && ($edition !~ /64/));
            } else {
                $result .= &dataXML($eltFullName, "osBitMode", 32);
            }
        }

        $result .= &dataXML($eltFullName, "edition", $edition) if ($edition);

        $result .= &dataXML($eltFullName, "osComputerDomain", $osComputerDomain) if ($osComputerDomain);

        $result .= &dataXML($eltFullName, "patchLevel", $patchLevel);

        $result .= &dataXML($eltFullName, "level2AccessOK", "1");
        $result .= &dataXML($eltFullName, "scanDate", &to_bdna_date(scalar(localtime())));

        if (scalar(@users) > 0) {
            $result .= &dataXML($eltFullName, "users", join($BDNA_Separator, @users));
        }
        if (scalar(@groups) > 0) {
            $result .= &dataXML($eltFullName, "groups", join($BDNA_Separator, @groups));
        }

        # uptime1 is obtained from WMI class Win32_OperatingSystem.LastBootUpTime 
        # uptime2 is obtained from WMI class Win32_PerfRawData_PerfOS_System 
        # uptime2 is more reliable than uptime1. But from our inhouse testing,
        # we get uptime2 only for Win2k, WinXP and Win2K3 and it is empty for NT and Vista.
        # But we do not get uptime1 from some Win2k boxes.
        # Inorder to populate the upTime attribute, we would first see if uptime1 has a value.
        # If so, we would use that, else we would use uptime2 value.
        if ($uptime1) {
            if ($uptime1 =~ /\d+/) {
                $result .= &dataXML($eltFullName, "upTime", $uptime1);
            }
        }
        elsif ($uptime2) {
            if ($uptime2 =~ /\d+/) {
                $result .= &dataXML($eltFullName, "upTime", $uptime2);
            }
        }
        if ($installDate) {
            $result .= &dataXML($eltFullName, "osInstallDate", $installDate);
        }

        # get license type from product ID
        my $midNumber;
        my $licenseType = "Unknown";
        if ($appProductID =~ /[0-9]{5}-(OEM)-[0-9]{7}-[0-9]{5}/) {
            $licenseType = "OEM";
        } else {
            if ($appProductID =~ /[0-9]{5}-([0-9]{3})-[0-9]{7}-[0-9]{5}/) {
                $midNumber = $1;
            }
            if ($midNumber =~ /550|63[0-6]/) {
                $licenseType = "OEM";
            } elsif ($midNumber =~ /000|436|460/) {
                $licenseType = "TRIAL";
            } elsif ($midNumber =~ /111|270|652|660/) {
                $licenseType = "SELECT [Volume License Key]";
            } elsif ($midNumber =~ /197|198|335|336|337|338|365|366|367|425/) {
                $licenseType = "MSDN";
            } elsif ($midNumber =~ /480|490|4[7-9][1-9]|72[1-9]|73[0-9]|74[0-4]/) {
                $licenseType = "Home Use Program (HUP)";
            } elsif ($midNumber =~ /64[0-9]|650/) {
                $licenseType = "OPEN [Volume License Key]";
            } elsif ($midNumber =~ /70[0-5]/) {
                $licenseType = "Visual Studio .NET";
            } elsif ($midNumber =~ /70[6-9]|71[0-2]/) {
                $licenseType = "Office XP or Open License";
            } elsif ($midNumber =~ /725|72[6-9]|73[0-6]/) {
                $licenseType = "Academic";
            } 
        }
        $result .= &dataXML($eltFullName, "appLicenseType", $licenseType); 

            
        # Wherever we cannot obtain Win32_BIOS.SerialNumber(e.g Dell PowerEdge 2450, PowerEdge 1550/886),
        # we populate the serialNumber attribute with the value of Win32_SystemEnclosure.SerialNumber if available.
        my $bogusbiosSerialNumber='';
        if ($biosSerialNumber) {
            $biosSerialNumber =~ s/^\s+//;
            $biosSerialNumber =~ s/\s+$//;
            my $tempbiosSerialNumber = $biosSerialNumber;
            $tempbiosSerialNumber =~ s/-//g;
            if ( ($tempbiosSerialNumber !~ /^(\w)\1+$/) && 
                    ($tempbiosSerialNumber !~ /^(\w)(\w)(\1\2)+$/) &&
                    ($biosSerialNumber ne 'None') && ($biosSerialNumber ne 'none') ) {
                $result .= &dataXML($eltFullName, "serialNumber", $biosSerialNumber);
                # Windows serial number can be bogus....
                # $result .= &dataXML($eltFullName, "deviceUniqueID", $biosSerialNumber);                
            }
            else {
                $bogusbiosSerialNumber = 'true';
            }
        }
        if ( (($bogusbiosSerialNumber eq 'true') or (!$biosSerialNumber)) && ($enclosureSerialNumber) ) {
            $enclosureSerialNumber =~ s/^\s+//;
            $enclosureSerialNumber =~ s/\s+$//;
            my $tempenclosureSerialNumber = $enclosureSerialNumber;
            $tempenclosureSerialNumber =~ s/-//g;
            if ( ($tempenclosureSerialNumber !~ /^(\w)\1+$/) &&
                    ($tempenclosureSerialNumber !~ /^(\w)(\w)(\1\2)+$/) &&
                    ($enclosureSerialNumber ne 'None') && ($enclosureSerialNumber ne 'none') ) {
                $result .= &dataXML($eltFullName, "serialNumber", $enclosureSerialNumber);
                # Windows serial number can be bogus....
                # $result .= &dataXML($eltFullName, "deviceUniqueID", $enclosureSerialNumber);
            }
        }

        if ($productUUID) {
            $productUUID =~ s/^\s+//;
            $productUUID =~ s/\s+$//;
            my $tempproductUUID = $productUUID;
            $tempproductUUID =~ s/-//g;
            if ( ($tempproductUUID !~ /^(\w)\1+$/) && 
                    ($tempproductUUID !~ /^(\w)(\w)(\1\2)+$/) && 
                    ($productUUID ne 'None') && ($productUUID ne 'none') ) {
                $result .= &dataXML($eltFullName, "hwUUID", $productUUID);                
            }
        }

        my $bogusproductIdentifyingNumber='';
        if ($productIdentifyingNumber) {
            $productIdentifyingNumber =~ s/^\s+//;
            $productIdentifyingNumber =~ s/\s+$//;
            my $tempproductIdentifyingNumber = $productIdentifyingNumber;
            $tempproductIdentifyingNumber =~ s/-//g;
            if ( ($tempproductIdentifyingNumber !~ /^(\w)\1+$/) && 
                    ($tempproductIdentifyingNumber !~ /^(\w)(\w)(\1\2)+$/) &&
                    ($productIdentifyingNumber ne 'None') && ($productIdentifyingNumber ne 'none') ) {
                $result .= &dataXML($eltFullName, "hwIdentNum", $productIdentifyingNumber);
            }
            else {
                $bogusproductIdentifyingNumber = 'true';
            }
        }
        if ( (($bogusproductIdentifyingNumber eq 'true') or (!$productIdentifyingNumber)) && ($enclosureSerialNumber) ) {
            $enclosureSerialNumber =~ s/^\s+//;
            $enclosureSerialNumber =~ s/\s+$//;
            my $tempenclosureSerialNumber = $enclosureSerialNumber;
            $tempenclosureSerialNumber =~ s/-//g;
            if ( ($tempenclosureSerialNumber !~ /^(\w)\1+$/) &&
                    ($tempenclosureSerialNumber !~ /^(\w)(\w)(\1\2)+$/) &&
                    ($enclosureSerialNumber ne 'None') && ($enclosureSerialNumber ne 'none') ) {
                $result .= &dataXML($eltFullName, "hwIdentNum", $enclosureSerialNumber);
            }
        }

        $hardware_ManufacModel = "$hw_manufacturer $hw_model";
        $result .= &dataXML($eltFullName, "hardware", $hardware_ManufacModel) if ($hw_manufacturer);
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <!-- Find Windows CPU data -->
    <rule
        name="findwindowsCPUDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
            <use attribute="hostName"/>
        </search>
        <output type="windows" attribute="numCPUs" />
        <output type="windows" attribute="CPUs" />
        <output type="root.types.resource.peripheral.cpu" />
        <output parentType="windows" childType="root.types.resource.peripheral.cpu" />         
        <output type="root.types.resource.peripheral.cpu" attribute="name" />
        <output type="root.types.resource.peripheral.cpu" attribute="manufacturer" />
        <output type="root.types.resource.peripheral.cpu" attribute="model" />
        <output type="root.types.resource.peripheral.cpu" attribute="isa" />
        <output type="root.types.resource.peripheral.cpu" attribute="bits" />
        <output type="root.types.resource.peripheral.cpu" attribute="speed" />
        <output type="root.types.resource.peripheral.cpu" attribute="maxSpeed" />
        <output type="root.types.resource.peripheral.cpu" attribute="cores" />
        <output type="root.types.resource.peripheral.cpu" attribute="threads" />
        <output type="root.types.resource.peripheral.cpu" attribute="percentUtilized" />
        <output type="windows" attribute="processorIds" />        
        <conclusion type="perl">
            <![CDATA[
#CPU creation - rewritten 2006-06-15 poppenheim
#see bug 10240 (and other associated bugs) for more details
#CPUs element & UDT:
#
#name
#manufacturer
#model
#isa
#bits
#speed
#maxSpeed
#cores (total on CPU)
#threads (total on CPU)
#
# Windows collection:
#arrayFields = array("ProcessorId","DeviceID","Manufacturer","MaxClockSpeed","Name","LoadPercentage","LoadPercentage","SocketDesignation")
#arrayItems  = array("cpu.processorId","cpu.id","cpu.manufacturer","cpu.speed","cpu.model","cpu.percentUsed","hardware.CPUUtilPercent","cpu.socket")
my $hostName = $windows{"hostName"};
$hostName =~ s/\./_/g;
my $type = "root.types.resource.peripheral.cpu" ;
my $parent = $windows{"elementFullName"};
my ($eltName,$eltFullName)='';
my $typeString = $windows{"systemData"};
@lines = split(/$BDNA_Separator/,$typeString);
$result = "<result>";
sub trim {
    my @out = @_;
    for (@out) {
        s/^\s+//;
        s/\s+$//;
    }
    return wantarray ? @out : $out[0];
}

# parse systemData cpu.* series
my %cpus;
foreach (@lines) {
    if (/^cpu\.(\D+)(\d+)=(.*)/){
        #there be an identifier in $1, and index in $2, and a value in $3, yarrr!!!
        my $key = &trim($1);
        my $index = &trim($2);
        my $value = &trim($3);
        $cpus{$index}->{$key} = $value;
        #$result .= "index: '$index' key: '$key' value: '$value'\n";
    } elsif (/^cpu\.([^=]+)=(.*)/) {
        #CPU, but not multiple, so no ID.
        my $key = &trim($1);
        my $index = 0;
        my $value = &trim($2);
        $cpus{$index}->{$key} = $value;
        #$result .= "index: '$index' key: '$key' value: '$value'\n";
    }
}

#debug deduping:
#foreach $index (sort keys %cpus) {
#    foreach $key (sort keys %{$cpus{$index}}) {
#        my $value = $cpus{$index}->{$key};
#        $result .= "index: '$index' key: '$key' value: '$value'\n";
#    }
#}
#$result .= "\n\n";

# now I need to dedup based on socket: http://www.xmilk.com/Home/tabid/36/EntryID/11/Default.aspx
my %sockets;
my $num_vcpus = scalar keys %cpus;
foreach $index (sort keys %cpus) {
    if (defined $sockets{$cpus{$index}->{"socket"}}) {
        #ran into this CPU already, baleet! (remember to delete, not undef)
        delete $cpus{$index};
    } else {
        $sockets{$cpus{$index}->{"socket"}}++;
    }
}

#debug deduping:
#foreach $index (sort keys %cpus) {
#    foreach $key (sort keys %{$cpus{$index}}) {
#        my $value = $cpus{$index}->{$key};
#        $result .= "index: '$index' key: '$key' value: '$value'\n";
#    }
#}

my $numCPUs = scalar keys %cpus;
if ($numCPUs > 0) {
    $result .= &dataXML($parent,"numCPUs",$numCPUs);
}

# WARNING NOTE BUGBUG BADBAD
# this is fuzzy logic, being used strictly because I have no other option.
my $remainder;
if ($num_vcpus != 0) {
    $remainder = $num_vcpus % $numCPUs;
}
my $threads;
if (defined $remainder && $remainder == 0) {
    #assume thread units spread over CPUs (usually hyperthreading) (poppenheim 2006-06)
    $threads = $num_vcpus / $numCPUs;
}

# processor serials
my $processorIds;
foreach $index (sort keys %cpus) {
    if (defined $cpus{$index}->{"processorId"}) {
        if ($processorIds ne "") {
            $processorIds .= "<BDNA,>";
        }
        $processorIds .= $cpus{$index}->{"processorId"};
    }
}
if (defined $processorIds) {
    $result .= &dataXML($parent,"processorIds",$processorIds);
}

#decode ISA enums
for (my $i, my @indexes = sort keys %cpus ; $i < scalar @indexes ; $i++) {
    my $isa = $cpus{$indexes[$i]}->{"isa"};
    if (!defined $isa || $isa eq '') {
        #something weird
        next;
    } elsif ($isa == 0) {
        $cpus{$indexes[$i]}->{"isaDecoded"} = "x86";
    } elsif ($isa == 1) {
        $cpus{$indexes[$i]}->{"isaDecoded"} = "MIPS";
    } elsif ($isa == 2) {
        $cpus{$indexes[$i]}->{"isaDecoded"} = "Alpha";
    } elsif ($isa == 3) {
        $cpus{$indexes[$i]}->{"isaDecoded"} = "PowerPC";
    } elsif ($isa == 6) {
        $cpus{$indexes[$i]}->{"isaDecoded"} = "ia64";
    } elsif ($isa == 9) {
        $cpus{$indexes[$i]}->{"isaDecoded"} = "x64";
    }
}

#now make UDT, element.
my @CPUs;
for (my $i, my @indexes = sort keys %cpus ; $i < scalar @indexes ; $i++) {
    my $id = trim($cpus{$indexes[$i]}->{"id"});
    my $eltFullName;
    if (defined $id) {
        $CPUs[$i] = "name=$id";
        $eltFullName = "$parent.$id";
        $result .= &elementXML($id,$type,$parent);
        $result .= &dataXML($eltFullName,"name",$id);
    } else {
        #not having an ID is pretty weird, can't make elt.
        next;
    }
    use SharedData::CPUManufacturerMap;
    my $manufacturer = &CPUManufacturerMap::getCPUManufacturerName($cpus{$indexes[$i]}->{"manufacturer"});
    if (defined $manufacturer && $manufacturer ne '') {
        $CPUs[$i] .= "<BDNA,1>manufacturer=$manufacturer";
        $result .= &dataXML($eltFullName,"manufacturer",$manufacturer);
    }
    my $model = $cpus{$indexes[$i]}->{"model"};
    if (defined $model && $model ne '') {
        $CPUs[$i] .= "<BDNA,1>model=$model";
        $result .= &dataXML($eltFullName,"model",$model);
    }
    my $speed = $cpus{$indexes[$i]}->{"currSpeed"};
    if (defined $speed && $speed > 0) {
        $CPUs[$i] .= "<BDNA,1>speed=$speed";
        $result .= &dataXML($eltFullName,"speed",$speed);
    }
    my $percentUtilized = $cpus{$indexes[$i]}->{"percentUsed"};
    if (defined $percentUtilized && $percentUtilized >= 0) {
        $CPUs[$i] .= "<BDNA,1>percentUtilized=$percentUtilized";
        $result .= &dataXML($eltFullName,"percentUtilized",$percentUtilized);
    }
    if (defined $threads && $threads > 0) {
        $CPUs[$i] .= "<BDNA,1>threads=$threads";
        $result .= &dataXML($eltFullName,"threads",$threads);
    }
    my $maxSpeed = $cpus{$indexes[$i]}->{"speed"};
    if (defined $maxSpeed && $maxSpeed > 0) {
        $CPUs[$i] .= "<BDNA,1>maxSpeed=$maxSpeed";
        $result .= &dataXML($eltFullName,"maxSpeed",$maxSpeed);
    }
    my $bits = $cpus{$indexes[$i]}->{"bits"};
    if (defined $bits && $bits ne '') {
        $CPUs[$i] .= "<BDNA,1>bits=$bits";
        $result .= &dataXML($eltFullName,"bits",$bits);
    }
    my $isa = $cpus{$indexes[$i]}->{"isaDecoded"};
    if (defined $isa && $isa ne '') {
        $CPUs[$i] .= "<BDNA,1>isa=$isa";
        $result .= &dataXML($eltFullName,"isa",$isa);
    }
    # bonus tofu
    my $processorId = $cpus{$indexes[$i]}->{"processorId"};
    if (defined $processorId && $processorId ne '') {
        $CPUs[$i] .= "<BDNA,1>processorId=$processorId";
        #$result .= &dataXML($eltFullName,"processorId",$processorId);
    }
    my $socket = $cpus{$indexes[$i]}->{"socket"};
    if (defined $socket && $socket ne '') {
        $CPUs[$i] .= "<BDNA,1>socket=$socket";
        #$result .= &dataXML($eltFullName,"socket",$socket);
    }
}

#spit CPU to UDT
my $cpu_udt = join("<BDNA,>", @CPUs);
if ($cpu_udt ne "") {
    $result .= &dataXML($parent,"CPUs",$cpu_udt);
}
$result .= "</result>";
            ]]>
        </conclusion>
    </rule>

    <!-- Find Windows filesystems data -->
    <rule
        name="findWindowsFilesystemsDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
            <use attribute="hostName"/>
        </search>
        <output type="root.types.resource.storageAllocation.fileSystem"/>
        <output parentType="windows" childType="root.types.resource.storageAllocation.fileSystem" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="name" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="type" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="mountPoint" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="capacity" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="availableCapacity" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="capacityUsed" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="percentUtilized" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="isLocal" />
        <output type="root.types.resource.storageAllocation.fileSystem" attribute="quotaEnabled" />
        <output type="root.types.resource.software.operatingSystem.Windows" includeSubtype="true" attribute="localFilesystemSpaceTotal" />
        <output type="root.types.resource.software.operatingSystem.Windows" includeSubtype="true" attribute="localFilesystemSpaceUsed" /> 
        <output type="root.types.resource.software.operatingSystem.Windows" includeSubtype="true" attribute="localFilesystemSpaceAvail" /> 
        <output type="root.types.resource.software.operatingSystem.Windows" includeSubtype="true" attribute="volumeSN" />
        <output type="root.types.resource.software.operatingSystem.Windows" includeSubtype="true" attribute="diskQuotaEnabled" />
        <conclusion type="perl">
        <![CDATA[
        our (%windows);
        my $hostName = $windows{"hostName"};
        $hostName =~ s/\./_/g;
        my $parent = $windows{"elementFullName"};
        my @lines = split(/$BDNA_Separator/, $windows{"systemData"});

        my $totalCapacity = 0;
        my $totalAvailableCapacity = 0;
        my $count = -1;
        my $osquotaenabled = "False";

        $result = "<result>";
        foreach my $line (@lines) {
            if ($line =~ /fileSystem\.mountPoint(\d*)=(.*)/) {
                $count++;
                my $id = $1;
                my $isLocal = "local";
                my $mountPoint = $2;
                my $diskquotaenabled = "False";
                my $eltName = "fileSystem" . $count . "_$hostName";
                my $eltFullName = "$parent.$eltName";
                
                if ($mountPoint ne '') {

                    $result .=
                        &elementXML($eltName, "root.types.resource.storageAllocation.fileSystem", $parent) .
                        &dataXML($eltFullName, "name", "Drive $mountPoint") .
                        &dataXML($eltFullName, "mountPoint", $mountPoint);
                    $isLocal="local";
                    my ($capacity, $availableCapacity);
                    foreach my $ln (@lines) {
                        if ($ln =~ /fileSystem\.type$id=(.+)/) {
                            $result .= &dataXML($eltFullName, "type", $1);
                        }
                        elsif ($ln =~ /fileSystem\.quotasDisabled$id=(.+)/) {
                            my $tempQuota = $1;
                            if ($tempQuota =~ /False/) {
                                $osquotaenabled = "True";
                                $diskquotaenabled = "True";
                                $result .= &dataXML($eltFullName, "quotaEnabled", "True");
                            }
                        }
                        elsif ($ln =~ /fileSystem\.capacity$id=(\d+)/) {
                            $capacity = $1;
                        }
                        elsif ($ln =~ /fileSystem\.availableCapacity$id=(\d+)/) {
                            $availableCapacity = $1;
                        }
                        elsif ($ln =~ /fileSystem.networkPath$id=(.+)$/) {
                            if( defined($1) && ($1) ){
                                $isLocal="remote";
                            }
                        }
                        elsif ($ln =~ /fileSystem.driveType$id=(.*)$/) {
                            if( defined($1) && $1 =~ /\b4\b/){
                                $isLocal="remote";
                            }
                        }
                        elsif ( ($mountPoint eq 'C:') && ($ln =~ /fileSystem.volumeSN$id=(\S+)/) ) {
                            $result .= &dataXML($windows{"elementFullName"}, "volumeSN", $1);
                        }
                    }
                    if ($capacity > 0 && defined($availableCapacity)) {
                      if ($windows{"elementFullName"} =~ /WindowsXP$/) {
                        if ($diskquotaenabled =~ /False/) {
                            my $capacityUsed = $capacity - $availableCapacity;
                            $result .= &dataXML($eltFullName, "capacity", $capacity);
                            $result .= &dataXML($eltFullName, "availableCapacity", $availableCapacity);
                            $result .= &dataXML($eltFullName, "capacityUsed", $capacityUsed);
                            $result .= &dataXML($eltFullName, "percentUtilized", sprintf("%2.0f", ($capacityUsed/$capacity)*100));
                        }
                        else {
                          $result .= &dataXML($eltFullName, "availableCapacity", $availableCapacity);
                        }
                      }
                      else {
                            my $capacityUsed = $capacity - $availableCapacity;
                            $result .= &dataXML($eltFullName, "capacity", $capacity);
                            $result .= &dataXML($eltFullName, "availableCapacity", $availableCapacity);
                            $result .= &dataXML($eltFullName, "capacityUsed", $capacityUsed);
                            $result .= &dataXML($eltFullName, "percentUtilized", sprintf("%2.0f", ($capacityUsed/$capacity)*100));
                      }
                    }
                    if ($isLocal !~ /remote/) {
                        $totalCapacity += $capacity;
                        $totalAvailableCapacity += $availableCapacity;
                    }
                    $result .= &dataXML($eltFullName, "isLocal", $isLocal );                        
                }
            }
        }
        if ($result ne "<result>") {
          if ($windows{"elementFullName"} =~ /WindowsXP$/) {
            if ($osquotaenabled =~ /False/) {
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceTotal", $totalCapacity);  
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceUsed", $totalCapacity - $totalAvailableCapacity);  
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceAvail", $totalAvailableCapacity);
            }
            else {
              $result .= &dataXML($windows{"elementFullName"}, "diskQuotaEnabled", "True");
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceAvail", $totalAvailableCapacity);
            }
          }
          else {
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceTotal", $totalCapacity);  
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceUsed", $totalCapacity - $totalAvailableCapacity);  
              $result .= &dataXML($windows{"elementFullName"}, "localFilesystemSpaceAvail", $totalAvailableCapacity);
          }
        }
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <!-- Find windows Hard disk data -->
    <rule
        name="findwindowsHarddiskDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
        </search>
        <output type="root.types.resource.software.operatingSystem" attribute="hddString" />    

        <conclusion type="perl">
        <![CDATA[
        our (%windows);
        my $hddString = '';

        
        my $parent = $windows{"elementFullName"};
        my @lines = split(/$BDNA_Separator/, $windows{"systemData"});

# Note there's only one boot partition indicated per Windows system.
# For lack of something smarter to do, we store that value for every
# hard disk.  (Trying to figure out which hard disk the boot
# partition is on, if any, would be quite tricky.)

        my $bootPartition;
        foreach my $line (@lines) {
            $bootPartition = $1 if ($line =~ /^hardDrive\.bootPartition=(.*)/);
        }

# Assumption: every hard drive has an idString value.  This loop will fail to
# parse and save data for hard drives that don't have idString values but
# for which other useful values are reported.

        our $result = "<result>";
        my $firstFlag, @idString_Parsed;
        foreach my $line (@lines) {
            $firstFlag=1; #Set flag to show parsing through new drive
            if ($line =~ /^hardDrive\.idString(\d*)=(.*)/) {
                my $id = $1;
                if($id){
                    push( @idString_Parsed, $id );
                }
                if ($2 && ( $id ? ( scalar(grep /$id/, @idString_Parsed) <= 1 ) : $firstFlag ) ) {
                    $hddString .= (($hddString) ? $BDNA_Separator : '');
                    foreach my $ln (@lines) {
                        if ($ln =~ /^hardDrive\.model$id=(.+)/) {
                            #If parsing new drive (firstFlag) skip SubSeparator
                            $hddString .= ( $firstFlag ? '' : $BDNA_SubSeparator )
                              . "name=$1" . $BDNA_SubSeparator . "model=$1";
                            $firstFlag = 0;
                            my $model=$1;
                            if( $model =~ /(\S+)(\s+\S+)+/ ){
                                $hddString = join( $BDNA_SubSeparator, $hddString, "manufacturer=$1");
                            }

                        } elsif ($ln =~ /^hardDrive\.type$id=(.+)/) {
                            $hddString .= ( $firstFlag ? '' : $BDNA_SubSeparator )
                              . "type=$1";
                            $firstFlag = 0;
                        } elsif ($ln =~ /^hardDrive\.capacity$id=(\d+)/) {
                            $hddString .= ( $firstFlag ? '' : $BDNA_SubSeparator )
                              . "capacity=$1";
                            $firstFlag = 0;
                        }

                    }
                    $hddString .= $BDNA_SubSeparator . "bootPartition=$bootPartition"
                        if ($bootPartition);
                }
            }
        }
        $result .= &dataXML($windows{"elementFullName"}, "hddString", $hddString ) if ($hddString ne "");
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <!-- Find windows CDROM data -->
    <rule
        name="findwindowsCDROMDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
            <use attribute="hostName"/>
        </search>
        <output type="root.types.resource.software.operatingSystem" attribute="cdromString" />    
        
        <conclusion type="perl">
          <![CDATA[
        my $hostName = $windows{"hostName"};
        $hostName =~ s/\./_/g;
        my $typeString = $windows{"systemData"};
        my $cdromString = '';
 
        @lines = split(/$BDNA_Separator/,$typeString);

        my ($cdrommanufacturer,$cdrommodel,$cdromdrive) = '';
        my ($count,$id) = 0;

        $result = "<result>";
        foreach $line (@lines) {
            if ($line =~ /CDROM\.manufacturer(\d+)=(.*)/) {
                $id = $1;
                $count += 1;
                $cdrommanufacturer=$2;
                $eltName="cdrom" . "$count" . "_$hostName";

                if ($cdrommanufacturer ne '') {
                    $cdromString .= (($cdromstring eq "") ? "" : $BDNA_Separator)
                      . "name=$eltName" . $BDNA_SubSeparator . "manufacturer=$cdrommanufacturer";
                    foreach $ln (@lines) {
                        if ($ln =~ /CDROM\.drive$id=(.*)/) {
                            $cdromdrive = $1;
                            if ($cdromdrive ne '') {
                                $cdromString .= $BDNA_SubSeparator . "drive=$cdromdrive"; 
                            }
                        }
                        elsif ($ln =~ /CDROM\.idString$id=(.*)/) {
                            $cdrommodel = $1;
                            if ($cdrommodel ne '') {
                                $cdromString .= $BDNA_SubSeparator . "model=$cdrommodel"; 
                            }
                        }
                    }
                }
            }
            elsif ($line =~ /CDROM\.manufacturer=(.*)/) {
                $cdrommanufacturer=$1;
                $eltName="cdrom_$hostName";

                if ($cdrommanufacturer ne '') {
                    $cdromString .= (($cdromstring eq "") ? "" : $BDNA_Separator)
                      . "name=$eltName" . $BDNA_SubSeparator . "manufacturer=$cdrommanufacturer";
                    foreach $ln (@lines) {
                        if ($ln =~ /CDROM\.drive=(.*)/) {
                            $cdromdrive = $1;
                            if ($cdromdrive ne '') {
                                $cdromString .= $BDNA_SubSeparator . "drive=$cdromdrive"; 
                            }
                        }
                        elsif ($ln =~ /CDROM\.idString=(.*)/) {
                            $cdrommodel = $1;
                            if ($cdrommodel ne '') {
                                $cdromString .= $BDNA_SubSeparator . "model=$cdrommodel"; 
                            }
                        }
                    }
                }
            }
        }
        $result .= &dataXML($windows{"elementFullName"}, "cdromString", $cdromString ) if ($cdromString ne "");
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <!-- Find windows Modem data -->
    <rule
        name="findwindowsModemDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
            <use attribute="hostName"/>
        </search>
        <output type="root.types.resource.peripheral.modem"/>    
        <output parentType="windows" childType="root.types.resource.peripheral.modem" />           
        <output type="root.types.resource.peripheral.modem" attribute="name" />
        <output type="root.types.resource.peripheral.modem" attribute="type" />
        <output type="root.types.resource.peripheral.modem" attribute="model" />        
        <output type="root.types.resource.peripheral.modem" attribute="capacity" />          
        <output type="root.types.resource.peripheral.modem" attribute="isActive" />          
        <output type="root.types.resource.peripheral.modem" attribute="description" />                   
        <conclusion type="perl">

            <![CDATA[
        my $hostName = $windows{"hostName"};
        $hostName =~ s/\./_/g;
        my $type = "root.types.resource.peripheral.modem" ;
        my $parent = $windows{"elementFullName"};

        my $typeString = $windows{"systemData"};
        @lines = split(/$BDNA_Separator/,$typeString);

        my ($modemtype,$modemmodel,$modemdescription) = '';
        my ($modemcapacity,$modemisactive,$count,$id) = 0;

        $result = "<result>";
        foreach $line (@lines) {
            if ($line =~ /modem\.model(\d+)=(.*)/) {
                $id = $1;
                $count += 1;
                $modemmodel=$2;
                $eltName="modem" . "$count" . "_$hostName";
                $eltFullName="$parent.$eltName" ;

                if ($modemmodel ne '') {
                    $result .=
                    &elementXML($eltName,$type,$parent) .
                    &dataXML($eltFullName,"name",$eltName) .
                    &dataXML($eltFullName,"model",$modemmodel);
                    foreach $ln (@lines) {
                        if ($ln =~ /modem\.type$id=(.*)/) {
                            $modemtype = $1;
                            if ($modemtype ne '') {
                                $result .= &dataXML($eltFullName,"type",$modemtype);
                            }
                        }
                        elsif ($ln =~ /modem\.capacity$id=(\d+)/) {
                            $modemcapacity = $1;
                            if ($modemcapacity > 0) {
                                $result .= &dataXML($eltFullName,"capacity",$modemcapacity);
                            }
                        }
                        elsif ($ln =~ /modem\.isActive$id=(\d)/) {
                            $modemisactive = $1;
                            if ($modemisactive >= 0) {
                                $result .= &dataXML($eltFullName,"isActive",$modemisactive);
                            }
                        }
                        elsif ($ln =~ /modem\.description$id=(.*)/) {
                            $modemdescription = $1;
                            if ($modemdescription ne '') {
                                $result .= &dataXML($eltFullName,"description",$modemdescription);
                            }
                        }
                    }
                }
            }
            elsif ($line =~ /modem\.model=(.*)/) {
                $modemmodel=$1;
                $eltName="modem_$hostName";
                $eltFullName="$parent.$eltName" ;

                if ($modemmodel ne '') {
                    $result .=
                    &elementXML($eltName,$type,$parent) .
                    &dataXML($eltFullName,"name",$eltName) .
                    &dataXML($eltFullName,"model",$modemmodel);
                    foreach $ln (@lines) {
                        if ($ln =~ /modem\.type=(.*)/) {
                            $modemtype = $1;
                            if ($modemtype ne '') {
                                $result .= &dataXML($eltFullName,"type",$modemtype);
                            }
                        }
                        elsif ($ln =~ /modem\.capacity=(\d+)/) {
                            $modemcapacity = $1;
                            if ($modemcapacity > 0) {
                                $result .= &dataXML($eltFullName,"capacity",$modemcapacity);
                            }
                        }
                        elsif ($ln =~ /modem\.isActive=(\d)/) {
                            $modemisactive = $1;
                            if ($modemisactive >= 0) {
                                $result .= &dataXML($eltFullName,"isActive",$modemisactive);
                            }
                        }
                        elsif ($ln =~ /modem\.description=(.*)/) {
                            $modemdescription = $1;
                            if ($modemdescription ne '') {
                                $result .= &dataXML($eltFullName,"description",$modemdescription);
                            }
                        }
                    }
                }
            }
        }
        $result .= "</result>";
        ]]>
        </conclusion>
    </rule>

    <!-- Find windows NIC data -->
    <rule name="findwindowsNICDataFromSystemData">
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
        </search>
        <output type="root.types.resource.operatingSystem.Windows" attribute="winNics" />

        <output type="windows" attribute="macAddresses" />        
        <output type="windows" attribute="systemMacAddresses" />                
        <conclusion type="perl">
        <![CDATA[
        our %windows;
        my ($count, %MACs);
        my $sysMacs = "";
        my (@winNicsFiltered, $winNicsFinal);

        my @lines = split(/$BDNA_Separator/, $windows{"systemData"});

        $result = "<result>";
        foreach my $seekingNicName (@lines) {
            if ($seekingNicName =~ /NIC\.name(\d*)=(.*)/) {
                my $id = $1;
                my $nicname = $2;

                $count++;

                if ($nicname ne '') {
                    my (@ips, @masks);
                    my $PNPDeviceID = "";
                    my $mac = "";
                    my $winNicsString = "name=NIC $count: $nicname" . $BDNA_SubSeparator . "nicName=$nicname";
                    foreach my $seekingData (@lines) {
                        if ($seekingData =~ /NIC\.PNPDeviceID$id=(.+)/) {
                            $PNPDeviceID .= $1;
                            $winNicsString .= $BDNA_SubSeparator . "PNPDeviceID=$1";
                        }
                        $winNicsString .= $BDNA_SubSeparator . "manufacturer=$1"
                            if ($seekingData =~ /NIC\.manufacturer$id=(.+)/);
                        $winNicsString .= $BDNA_SubSeparator . "DNS=$1"
                            if ($seekingData =~ /NIC\.DNSServers$id=(.+)/);

                        if ($seekingData =~ /NIC\.dhcpEnabled$id=(.+)/) {
                            $winNicsString .= $BDNA_SubSeparator ."DHCPEnabled=$1";
                        }
                        if ($seekingData =~ /NIC\.dhcpServer$id=(.+)/) {
                            $winNicsString .= $BDNA_SubSeparator ."DHCPServer=$1";
                        }
                        if ($seekingData =~ /NIC\.dhcpLeaseExpires$id=(\d)(\d)(\d)(\d)(\d)(\d)(\d)(\d)/) {
                            $winNicsString .= $BDNA_SubSeparator ."DHCPLeaseExpires=$1$2$3$4/$5$6/$7$8";
                        }
                        if ($seekingData =~ /NIC\.WINSPrimaryServer$id=(.+)/) {
                            $winNicsString .= $BDNA_SubSeparator ."WINSPrimarySvr=$1";
                        }
                        if ($seekingData =~ /NIC\.WINSSecondaryServer$id=(.+)/) {
                            $winNicsString .= $BDNA_SubSeparator ."WINSSecondarySvr=$1";
                        }
                        if ($seekingData =~ /NIC\.DNSServerSearchOrder$id=(.+)/) {
                            my $DNSSearchOrderString = $1;
                            if ($DNSSearchOrderString) {
                                my @DNSServer = split(/,/, $DNSSearchOrderString);

                                my $otherDNSSvr = "";
                                my $count = 0;
                                for ($count-0; $count <= scalar(@DNSServer); $count++) {
                                    if ($count == 0) {
                                        $winNicsString .= $BDNA_SubSeparator ."PrimaryDNSSvr=".$DNSServer[0];
                                    } elsif ($count == 1) {
                                        $winNicsString .= $BDNA_SubSeparator ."SecondaryDNSSvr=".$DNSServer[1];
                                    } elsif ($count == 2) {
                                        $winNicsString .= $BDNA_SubSeparator ."TertiaryDNSSvr=".$DNSServer[2];
                                    } elsif ($count >= 2) {
                                        if ($DNSServer[$count]) {
                                            if ($otherDNSSvr) {
                                                $otherDNSSvr .= ',';
                                            }
                                            $otherDNSSvr .= $DNSServer[$count];
                                        }
                                    }
                                }
                                $winNicsString .= $BDNA_SubSeparator ."OtherDNSSvr=".$otherDNSSvr;
                                $winNicsString .= $BDNA_SubSeparator ."DNSSearchOrder=".$DNSSearchOrderString;
                            }
                        }

                        if ($seekingData =~ /NIC\.IPAddress$id=(.+)/) {
                           foreach my $ip (split(/,/, $1)) {
                              if ($ip ne "0.0.0.0"
                                  && $ip ne "255.255.255.255"
                                  && $ip !~ m/^127/) {
                                  push(@ips, $ip);
                              }
                           }
                           #$winNicsString .= $BDNA_SubSeparator . "IPAddress=$1";
                        }
                        $winNicsString .= $BDNA_SubSeparator . "defaultRoute=$1"
                            if ($seekingData =~ /NIC\.defaultRoute$id=(.+)/);
                        #$winNicsString .= $BDNA_SubSeparator . "networkMask=$1"
                        @masks = split(/,/, $1) if ($seekingData =~ /NIC\.networkMask$id=(.+)/);
                        if ($seekingData =~ /NIC\.MACAddress$id=(.+)/) {
                            $winNicsString .= $BDNA_SubSeparator . "MACAddress=$1";
                            $mac = $1;
                        }
                    }
                    # the following logic is slightly more complicated than it used to be,
                    # but no longer makes the false assumption that we will get a PNPDeviceID.
                    # See bug 10259 for more info.
                    #
                    #  Filter out software network adapters for the nic element
                    my $addNic = 0;
                    if (defined $PNPDeviceID) {
                        if ($PNPDeviceID =~ m/^root\\/i || $PNPDeviceID =~ m/^sw\\/i) {
                            $addNic = -1;
                        } else {
                            $addNic = 1;
                        }
                    }
                    if ($addNic != -1 && $nicname !~ m/RAS Async Adapter/ && $nicname !~ m/^WAN Miniport \(.+\)/ && $nicname !~ m/Direct Parallel/) {
                        $addNic = 1;
                    } else {
                        $addNic = -1;
                    }
                    if (-1 == $addNic && $nicname =~ m/Intel.*Advanced Network Services Virtual Adapter/) {
                        $addNic = 1;
                    } 
                    if (1 == $addNic) {
                        if (@ips && @masks) {
                            for ($i = 0; $i < @ips; $i++) {
                                my $winNics .= $winNicsString . $BDNA_SubSeparator . "IPAddress=$ips[$i]";
                                $winNics .= $BDNA_SubSeparator . "networkMask=$masks[$i]";
                                push(@winNicsFiltered, $winNics);
                            }
                        } else {
                            push(@winNicsFiltered, $winNicsString);
                        }
                    }
                    # Filter out nics that are likely to move around a lot
                    if ($mac) {
                        if (1 == $addNic) {
                            $MACs{$mac}++;
                        }
                        my $addSysMac = 0;
                        if (defined $PNPDeviceID) {
                            if ($PNPDeviceID =~ m/^PCMCIA/) {
                                $addSysMac = -1;
                            } else {
                                $addSysMac = 1;
                            }
                        }
                        if ($addSysMac != -1 && $nicname !~ m/\b(pccard|pc card|pcmcia)\b/i && $nicname !~ m/VMware Virtual Ethernet Adapter/) {
                            $addSysMac = 1;
                        } else {
                            $addSysMac = -1;
                        }
                        if (1 == $addSysMac && 1 == $addNic) {
                            if (!$sysMacs) {
                                $sysMacs = $mac;
                            } else {
                                $sysMacs .= $BDNA_Separator . $mac;
                            }
                        }
                    }
                }
            }
        }
        # "macAddresses" attribute needed for device element creation.
        $winNicsFinal = join($BDNA_Separator, @winNicsFiltered);
        $result .= &dataXML($windows{"elementFullName"}, "winNics", $winNicsFinal ) if ($winNicsFinal);
        $result .= &dataXML($windows{"elementFullName"}, "macAddresses", join($BDNA_Separator, sort(keys %MACs)))
            if (scalar(keys %MACs) > 0);
        $result .= &dataXML($windows{"elementFullName"}, "systemMacAddresses", $sysMacs) if ($sysMacs);
        $result .= "</result>";
        ]]>        
        </conclusion>
    </rule>

    <!-- Find Windows printer data -->
    <rule
        name="findwindowsPrinterDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
            <use attribute="hostName"/>
        </search>
        <output type="root.types.resource.peripheral.printer"/>
        <output parentType="windows" childType="root.types.resource.peripheral.printer" />
        <output type="root.types.resource.peripheral.printer" attribute="name" />
        <output type="root.types.resource.peripheral.printer" attribute="manufacturer" />
        <output type="root.types.resource.peripheral.printer" attribute="port" />
        <output type="root.types.resource.peripheral.printer" attribute="sharedName" />
        <output type="root.types.resource.peripheral.printer" attribute="isLocal" />
        <output type="root.types.resource.peripheral.printer" attribute="printerConnected" />
        <output type="root.types.resource.peripheral.printer" attribute="printerVirtual" />
        <output type="root.types.resource.peripheral.printer" attribute="model" />
        <conclusion type="perl">
            <![CDATA[
                our %windows;
                my $hostName = $windows{"hostName"};
                my $parent = $windows{"elementFullName"};
                my @lines = split(/$BDNA_Separator/, $windows{"systemData"});
                $result = "<result>";
                #DEBUGDEBUG
                #$result .= "\n line count: " . scalar(@lines) . "\n";
                #my $count;
                
                #Hashes to determine whether a printer is real or virtual.
                # see bug 9708
                my (@known_software_printers, @known_hardware_printers);
                #hardware - consider as Regex (like fingerprint.src)
                @known_hardware_printers = (
                    #please sort alphabetically when adding
                    "Brother MFC",
                    "Brother HL",
                    "Canon", 
                    "EPSON Stylus Photo",
                    "Epson Stylus COLOR",
                    "HP Color LaserJet", 
                    "HP DeskJet", 
                    "hp deskjet", 
                    "hp business inkjet", 
                    "hp LaserJet", 
                    "HP LaserJet", 
                    "hp psc", 
                    "Samsung ML",
                );
                #software - consider as full match (to avoid false positive)
                @known_software_printers = (
                    "ActiveTouch Document Loader",
                    "AdobePS Acrobat Distiller",
                    "Adobe PDF Converter",
                    "Amyuni Document Converter",
                    "Amyuni PDF Converter",
                    "easyPDF Printer",
                    "eFax",
                    "File, Print FedEx Kinko's", 
                    "Microsoft Office Live Meeting Document Writer Driver",
                    "Microsoft Office Document Image Writer Driver",
                    "Microsoft Shared Fax Driver",
                    "Microsoft XPS Document Writer",
                    "PaperPort Color Printer Driver",
                    "PaperPort Mono Printer Driver",
                    "PDF-XChange",
                    "SolidPDFConverter",
                    "SnagIt",
                    "WebEx Document Loader",
                );
                foreach my $line (@lines) {
                    #DEBUGDEBUG
                    #$result .= "\n line $count: $line\n";
                    #$count += 1;
                    if ($line =~ /^printer\.name(\d*)=(.+)/) {
                        my ($name, $port, $sharedName, $isLocal, $isConnected, $isVirtual, $driver);
                        my $id = $1;
                        my $printerName = $2;
                        $name = $printerName;
                        #my $eltName = 'printer' . $id . '_' . $hostName;
                        my $eltName = $name;
                        $eltName =~ s/\./_/g;
                        my $eltFullName = "$parent.$eltName";
                        
                        $result .=
                            &elementXML($eltName, "root.types.resource.peripheral.printer", $parent) .
                            &dataXML($eltFullName, "name", "$printerName");
                        foreach my $ln (@lines) {
                            #printer.driverName
                            if ($ln =~ /^printer\.port$id=(.+)/) {
                                $port = $1;
                                $result .= &dataXML($eltFullName, "port", $port);
                            }
                            elsif ($ln =~ /^printer\.sharedName$id=(.+)/) {
                                $sharedName = $1;
                                $result .= &dataXML($eltFullName, "sharedName", $sharedName);
                            }
                            elsif ($ln =~ /^printer\.driverName$id=(.+)/) {
                                $driver = $1;
                                $result .= &dataXML($eltFullName, "model", $driver);
                            }
                            elsif ($ln =~ /^printer\.local$id=(.+)/) {
                                #see bug 9708
                                my $temp = $1;
                                if ($temp =~ /true/i) {
                                    $isLocal = 1;
                                    $result .= &dataXML($eltFullName, "isLocal", $isLocal);
                                }
                                elsif ($temp =~ /false/i) {
                                    $isLocal = 0;
                                    $result .= &dataXML($eltFullName, "isLocal", $isLocal);
                                }
                            }
                            elsif ($ln =~ /^printer\.WorkOffline$id=(.+)/) {
                                #see bug 9708
                                my $temp = $1;
                                if ($temp =~ /true/i) {
                                    #know it's disconnected from the computer
                                    $isConnected = "False";
                                    $result .= &dataXML($eltFullName, "printerConnected", $isConnected);
                                }
                                elsif ($temp =~ /false/i) {
                                    #can't make solid conclusion
                                    $result .= &dataXML($eltFullName, "printerConnected", "Unknown");
                                }
                            }
                        }
                        #for each printer discovered, determine whether a printer is real or virtual.
                        #check against software printers
                        #$isVirtual = grep(/$driver/,@known_software_printers);
                        undef $isVirtual;
                        foreach my $virtualRegex (@known_software_printers) {
                          if ($driver =~ /$virtualRegex/) {
                            $isVirtual = "True";
                          }
                        }
                        #check against hardware printers
                        foreach my $printerRegex (@known_hardware_printers) {
                          if ($driver =~ /$printerRegex/) {
                            $isVirtual = "False";
                          }
                        }
                        if (defined($isVirtual)) {
                            $result .= &dataXML($eltFullName, "printerVirtual", "$isVirtual");
                        } else {
                            $result .= &dataXML($eltFullName, "printerVirtual", "Unknown");
                        }
                    } elsif ($line =~ /^printerViaRegistry=(.*)/) {
                        #each Registry printer is delimited by BDNA_SUB_SEP
                        # and each value per-printer is delimited by BDNA_SUB_SUB_SEP
                        #(like a UDT, one level in)
                        my $printerViaRegLine = $1;
                        my @printerLines = split(/$BDNA_SubSeparator/, $printerViaRegLine);
                        #DEBUGDEBUG
                        #$result .= "\n line: $line\n";
                        foreach my $printerLine (@printerLines) {
                            my @printerValues = split(/$BDNA_Sub2Separator/, $printerLine);
                            my ($name, $manufacturer, $port, $sharedName, $local, $isConnected, $isVirtual, $driver);
                            my ($statusBits, $attributeBits);
                            #DEBUGDEBUG
                            #$result .= "\n printerLine: $printerLine\n";
                            #$result .= "\n printerLine: @printerValues\n";
                            $name = "";
                            foreach my $value (@printerValues) {
                                if ($value =~ /name=(.*)/) {
                                    $name = $1;
                                } elsif ($value =~ /port=(.*)/) {
                                    $port = $1;
                                } elsif ($value =~ /sharedName=(.*)/) {
                                    $sharedName = $1;
                                } elsif ($value =~ /statusBits=(\d*)/) {
                                    $statusBits = $1;
                                } elsif ($value =~ /attributeBits=(\d*)/) {
                                    $attributeBits = $1;
                                } elsif ($value =~ /driver=(.*)/) {
                                    $driver = $1;
                                    if ($driver =~ /^(\S+)/) {
                                      $manufacturer = $1;  
                                    }
                                }
                            }
                            #DEBUGDEBUG
                            #$result .= "\n printer parsed: $name * $port * $sharedName * $statusBits * $attributeBits\n";
                            if ($name eq "") {
                                next;
                            }
                            #11363 - If the port is TS<port#> ignore this entry as this signifies terminal service printer
                            if ($port  =~ /TS\d+/) {
                                next;
                            }

                            #process the Bitstrings
                            if (defined($attributeBits)) {
                                #this bitmask is for the "WorkOffline" attribute
                                #checked as valid for Win2k, WinXP, Win2k3
                                # poppenheim - 2006-04-10
                                my $offlineMask = 0x00000400;
                                if ($attributeBits & $offlineMask) {
                                    #WorkOffline - know it's disconnected from the computer
                                    $isConnected = "False";
                                } else {
                                    if ($port  =~ /USB\d+/) {
                                      $isConnected = "True";
                                    } else {
                                      $isConnected = "Unknown";
                                    }
                                }
                            }

                            #for each printer discovered, determine whether a printer is real or virtual.
                            #check against software printers
                            #$isVirtual = grep(/$driver/,@known_software_printers);
                            undef $isVirtual;
                            foreach my $virtualRegex (@known_software_printers) {
                              if ($driver =~ /$virtualRegex/) {
                                $isVirtual = "True";
                              }
                            }
                            #check against hardware printers
                            foreach my $printerRegex (@known_hardware_printers) {
                              if ($driver =~ /$printerRegex/) {
                                $isVirtual = "False";
                              }
                            }
                            if (!defined($isVirtual)) {
                              $isVirtual = "Unknown";
                            }

                            #write the results out
                            my $eltName = $name;
                            $eltName =~ s/\./_/g;
                            my $eltFullName = "$parent.$eltName";
                            $result .= &elementXML($eltName, "root.types.resource.peripheral.printer", $parent);
                            $result .= &dataXML($eltFullName, "name", "$name");
                            if (defined($manufacturer)) {
                                $result .= &dataXML($eltFullName, "manufacturer", "$manufacturer");
                            }
                            if (defined($port)) {
                                $result .= &dataXML($eltFullName, "port", "$port");
                            }
                            if (defined($sharedName)) {
                                $result .= &dataXML($eltFullName, "sharedName", "$sharedName");
                            }
                            if (defined($local)) {
                                $result .= &dataXML($eltFullName, "local", "$local");
                            }
                            if (defined($isConnected)) {
                                $result .= &dataXML($eltFullName, "printerConnected", "$isConnected");
                            }
                            if (defined($isVirtual)) {
                                $result .= &dataXML($eltFullName, "printerVirtual", "$isVirtual");
                            }
                            if (defined($driver)) {
                                $result .= &dataXML($eltFullName, "model", "$driver");
                            }
                            $result .= &dataXML($eltFullName, "isLocal", "1");
                        }
                    }
                }
                $result .= "</result>";
            ]]>
        </conclusion>
    </rule>
    
    <!-- Find Windows Video Card data -->
    <rule
        name="findwindowsVideoDataFromSystemData"
        weight="90" >
        <search variable="windows" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="systemData" />
            <use attribute="hostName"/>
        </search>
        <output type="windows" attribute="VGAController" />
        <conclusion type="perl">
            <![CDATA[
#Video Card parsing - 2007-01-19 poppenheim
#see Bug 11691 - Need to capture video card information
my $hostName = $windows{"hostName"};
$hostName =~ s/\./_/g;
#my $type = "root.types.resource.peripheral.cpu" ;
my $parent = $windows{"elementFullName"};
#my ($eltName,$eltFullName)='';
my $typeString = $windows{"systemData"};
@lines = split(/$BDNA_Separator/,$typeString);
$result = "<result>";
sub trim {
    my @out = @_;
    for (@out) {
        s/^\s+//;
        s/\s+$//;
    }
    return wantarray ? @out : $out[0];
}

# store systemData video.* series
my %videoControllers;
foreach (@lines) {
    if (/^video\.(\D+)(\d+)=(.*)/){
        # multiple, has ID
        my $key = &trim($1);
        my $index = &trim($2);
        my $value = &trim($3);
        $videoControllers{$index}->{$key} = $value;
        #$result .= "index: '$index' key: '$key' value: '$value'\n";
    } elsif (/^video\.([^=]+)=(.*)/) {
        #singular, no ID
        my $key = &trim($1);
        my $index = 0;
        my $value = &trim($2);
        $videoControllers{$index}->{$key} = $value;
        #$result .= "index: '$index' key: '$key' value: '$value'\n";
    }
}

#now make UDT, element.
#currently:
#video.AdapterCompatibility1=NVIDIA
#video.AdapterRAM1=268435456
#video.Description1=NVIDIA GeForce 6200 TurboCache(TM)
#video.Name1=NVIDIA GeForce 6200 TurboCache(TM)
my @VideoLines;
for (my $i, my @indexes = sort keys %videoControllers ; $i < scalar @indexes ; $i++) {
    my $name = trim($videoControllers{$indexes[$i]}->{"Name"});
    my $eltFullName;
    # attr for Peregrine integration
    if (defined $name) {
        $VideoLines[$i] = "name=$name";
        $eltFullName = "$parent.$name";
        #$result .= &elementXML($name,$type,$parent);
        #$result .= &dataXML($eltFullName,"name",$name);
    } else {
        #not having a name is pretty weird, can't make elt.
        next;
    }
    my $Description = $videoControllers{$indexes[$i]}->{"Description"};
    if (defined $Description && $Description ne '') {
        $VideoLines[$i] .= "<BDNA,1>description=$Description";
        #$result .= &dataXML($eltFullName,"description",$Description);
    }
    my $AdapterRAM = $videoControllers{$indexes[$i]}->{"AdapterRAM"};
    if (defined $AdapterRAM && $AdapterRAM ne '') {
        $VideoLines[$i] .= "<BDNA,1>memory=$AdapterRAM";
        #$result .= &dataXML($eltFullName,"memory",$AdapterRAM);
    }
    my $AdapterCompatibility = $videoControllers{$indexes[$i]}->{"AdapterCompatibility"};
    if (defined $AdapterCompatibility && $AdapterCompatibility ne '') {
        $VideoLines[$i] .= "<BDNA,1>AdapterCompatibility=$AdapterCompatibility";
        #$result .= &dataXML($eltFullName,"AdapterCompatibility",$AdapterCompatibility);
    }
}

#spit CPU to UDT
my $video_udt = join("<BDNA,>", @VideoLines);
if ($video_udt ne "") {
    $result .= &dataXML($parent,"videoControllers",$video_udt);
}
$result .= "</result>";
            ]]>
        </conclusion>
    </rule>
    
    <!-- parse storageDevices from hddString -->
    <rule
        name="parseStorageDevicesFromHddStringWindows"
        weight="90" >
        <search variable="os" pattern="root.types.resource.software.operatingSystem.Windows" >
            <use attribute="hddString" />
        </search>
        <output type="os" attribute="storageDevices" />
        <conclusion type="perl">
            <![CDATA[
#Storage Device parsing - 2007-01-29 poppenheim
#see Bug 11694 - Collect more information for hddString (Hard Disk Drive String) UDT attribute
my $element = $os{"elementFullName"};
$result = "<result>";

my @devices;
my $hddString = $os{"hddString"};
my $storageDevices;

#hdds
my @hdds = split(/$BDNA_Separator/,$hddString);
foreach my $line (@hdds) {
    my @attrs = split(/$BDNA_SubSeparator/,$line);
    #attrs:
    # name - (lin) device name (win) model name
    # manufacturer
    # model
    # type - connection type
    # capacity
    # bootPartition
    # serialNumber
    my @dev;
    my ($deviceName, $manufacturer, $model, $connectionType, $capacity, $serialNumber);
    push @dev, "deviceType=Hard Drive";
    foreach (@attrs) {
        if (/^name=(.*)/) {
            $deviceName = $1;
            push @dev, "deviceName=$deviceName";
        } elsif (/^manufacturer=(.*)/) {
            $manufacturer = $1;
            push @dev, "manufacturer=$manufacturer";
        } elsif (/^model=(.*)/) {
            $model = $1;
            push @dev, "model=$model";
        } elsif (/^type=(.*)/) {
            $connectionType = $1;
            push @dev, "connectionType=$connectionType";
        } elsif (/^capacity=(\d+)$/) {
            $capacity = $1;
            push @dev, "capacity=$capacity";
        } elsif (/^serialNumber=(.*)/) {
            $serialNumber = $1;
            push @dev, "serialNumber=$serialNumber";
        }
    }
    #Yes, that's an or. Better to have a nasty name than null
    if ( ($deviceName ne "") || ($model ne "") ) {
        push @dev, "name=$deviceName ($model)";
    }
    my $dev = join $BDNA_SubSeparator, @dev;
    push @devices, $dev;
}

#output storageDevices
my $storage_udt = join("<BDNA,>", @devices);
if ($storage_udt ne "") {
    if ($storageDevices ne "") {
        $storageDevices .= "<BDNA,>";
    }
    $storageDevices .= $storage_udt;
    $result .= &dataXML($element,"storageDevices",$storageDevices);
}
$result .= "</result>";
            ]]>
        </conclusion>
    </rule>
    
<!-- Disable NoCred credentials to disallow this type of collection see bug# 8959    
    <connScriptBundle connMethodEFN="root.types.collection.connectionMethod.windowsNoCred">
        <scriptRef name="connWincsDummyScript" scriptType="connection" seqNum="1" />
    </connScriptBundle>
-->    

    <connScriptBundle connMethodEFN="root.types.collection.connectionMethod.windows.wincs.defaultwincs">
        <scriptRef name="ConnWincsScript" scriptType="connection" seqNum="1" />
    </connScriptBundle>
<!-- Dummy connection script for wincs type connections, a place hold for script arg -->
    <scriptTable
        scriptName="connWincsDummyScript"
        scriptVersion="1.0">
        <scriptArg isGlobal="false" 
          argNamePattern="%atr%"
          efnSource="root.types.internetAddress" 
          attributeName="address" />
        <![CDATA[No script required!]]>
    </scriptTable>

    <scriptTable
        scriptName="ConnWincsScript"
        scriptVersion="1.0">
        <scriptArg isGlobal="false" 
          argNamePattern="%atr%"
          efnSource="root.types.internetAddress" 
          attributeName="address" />
        <scriptArg isGlobal="false"  isOptional="true"
          argNamePattern="%atr%"
          efnSource="root.types.resource.software.operatingSystem.Windows"
          attributeName="osWkgrpDomain" />
    </scriptTable>

    <scriptTable
        scriptName="ConnWincsRemoteExecScript"
        scriptVersion="1.0">
        <scriptArg isGlobal="false"
          argNamePattern="%atr%"
          efnSource="root.types.internetAddress"
          attributeName="address" />
        <scriptArg isGlobal="false"
          argNamePattern="%atr%"
          efnSource="root.types.resource.software.operatingSystem.Windows"
          attributeName="osWkgrpDomain" />
    </scriptTable>

    <scriptTable
        scriptName="WinStaticDomainCheckScript"
        scriptVersion="1.0">
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.internetAddress"
            attributeName="address" />
        <![CDATA[
        my $homeDir = $BDNA_Params{"bdna.home"};
        my $rpcclient = "$homeDir/nih/samba/bin/rpcclient.Linux";
        chmod( 0555, $rpcclient ) if ( !-x $rpcclient );
        my $ipaddress = $BDNA_Params{"address"};
        my @lines = &LOCALshellcmd("($rpcclient -U % -c lsaquery $ipaddress 2>/dev/null)");
        chomp(@lines);

        foreach (@lines) {
            if (/^domain [[:alpha:]]* has sid S\-[^(0\-)]/i) {
                $BDNA_Results{"isDomainMember"} = "Yes";
            }
        }

        $BDNA_ErrorCode = 0;
        $BDNA_ResultCode = "com.bdna.cle.scripts.success";
        $BDNA_MessageBundle = "MessagesBundle";

        ]]>
    </scriptTable>

    <scriptTable
        scriptName="WinTypingStaticScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="WinStaticScript"
        scriptVersion="1.0">
    </scriptTable>

   <scriptTable
        scriptName="WinAppStaticScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="WinRegScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="WinFilePropertiesScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="RSOPPropertiesScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="WinFileContentScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="WindowsRemoteCommandExecutionScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="WinFileSearchScript"
        scriptVersion="1.0">
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="filter" />
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="drive" />
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="driveName" />
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="mountPoint" />
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="capacity" />
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="isLocal" />
        <scriptArg isGlobal="false" isOptional="false"
            argNamePattern="%atr%"
            efnSource="root.types.footprint.WindowsFileScanCollectorFootprint"
            attributeName="splitQuery" />
    </scriptTable>
    
<!-- Disabling SU collection for 6.1.0 as per bug #17304
    <scriptTable
        scriptName="SoftwareUsageScript"
        scriptVersion="1.0">
    </scriptTable>
-->

    <scriptTable
        scriptName="RemoveWindowsProfileScript"
        scriptVersion="1.0">
    </scriptTable>        

    <scriptTable
        scriptName="ODBCDriversCollectionScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="NTPTimeServerCollectionScript"
        scriptVersion="1.0">
    </scriptTable>

    <scriptTable
        scriptName="RAIDDataStaticScript"
        scriptVersion="1.0">
        <![CDATA[
        my $host = $BDNA_Connection_Info{"SNMP_session_address"} || $BDNA_Params{"root.types.internetAddress:address"};
        my $port = $BDNA_Connection_Info{"SNMP_session_port"} || "161";
        my $community = $BDNA_Connection_Info{"SNMP_session_community"} || "public";
        my $privateMIBDir = join($BDNA_Params{"file.separator"}, $BDNA_Params{"bdna.home"}, "nih", "SNMP", "MIBs");
        my ($phyDiskResultBuffer, $cntlrResultBuffer, $logDiskResultBuffer) = ("", "", "");

        # Save the current directory path.
        my $pwd = `pwd`;
        my $mibdir = "$privateMIBDir/Dell -M +/usr/share/snmp/mibs";
        my $resultBuffer = '';
        my ($RAIDCntlrData, $RAIDPhyData, $RAIDLogData) = ('', '', '');

        if (!defined($host) || !defined($port) || !defined($community)) {
            $BDNA_ErrorCode = 0;
            #$BDNA_ResultCode = "com.bdna.cle.scripts.invalidParams";
            # Avoid overflowing system with not useful error.
            $BDNA_ResultCode = "com.bdna.cle.scripts.success";
            $BDNA_MessageBundle = "MessagesBundle";
            &echo("Connection not established because of invalid parameters: host='$host', port='$port' and community=__SNMP_COMMUNITY_STRING_NOT_LOGGED__.");
        } else {
            # First check if it is Dell Raid controller
            my $snmp_options;

            my $securityLevel = $BDNA_Connection_Info{"SNMP_session_securitylevel"};
            if(defined($securityLevel) && $securityLevel ne "") {
                my $snmp_options_part = $BDNA_Connection_Info{"SNMP_session_options"};
                $snmp_options = "-M $mibdir -v 3 -Oq -Os $snmp_options_part";
            } else {
                $snmp_options = "-M $mibdir -v 2c -Oq -Os -c '$community'";
            }

            #my $snmp_options = "-M $mibdir -v 2c -Oq -Os -c '$community'";
            my $snmp_cmd = "snmpwalk -m StorageManagement-MIB $snmp_options $host:$port ";
            &echo("Executing Dell snmp query: <$snmp_cmd physicalDevices.arrayDiskTable>.\n");
            $RAIDPhyData = LOCALshellcmd($snmp_cmd . 'physicalDevices.arrayDiskTable');
            my (%controllerTable, %phyDiskTable, %logDiskTable, %diskEnclosureTable) = ();
            if ($RAIDPhyData && $RAIDPhyData =~ /\narrayDisk/) {
                &echo("Dell RAID Controller detected.");
                my $snmp_ctlr_cmd = $snmp_cmd . "physicalDevices.controllerTable";
                &echo("Executing Dell snmp query: <$snmp_ctlr_cmd>.\n");
                $RAIDCntlrData = `$snmp_ctlr_cmd`;

                my $snmp_logDisk_cmd = $snmp_cmd . "logicalDevices.virtualDiskTable";
                &echo("Executing Dell snmp query: <$snmp_logDisk_cmd>.\n");
                $RAIDLogData = `$snmp_logDisk_cmd`;
                foreach my $line (split(/\n/, $RAIDCntlrData)) {
                    if ($line =~  /^controller(\w+?)\.(\d+)\s+\"?(.+?)\"?$/) {
                        my ($cntlrIndex, $propName, $propValue) = ($2, $1, $3);
                        chomp($cntlrIndex); chomp($propName); chomp($propValue);
                        $cntlrIndex =~ s/^\s+//; $cntlrIndex =~ s/\s+$//;
                        $propName =~ s/^\s+//; $propName =~ s/\s+$//;
                        $propValue =~ s/^\s+//; $propValue =~ s/\s+$//;
                        $controllerTable{$cntlrIndex}{$propName} = $propValue;
                        if (!$controllerTable{$cntlrIndex}{"elementType"}) {
                             $controllerTable{$cntlrIndex}{"elementType"} = "dellCntlr";
                        }
                    }
                }
                foreach my $line (split(/\n/, $RAIDPhyData)) {
                    if ($line =~ /^arrayDisk(.+?)\.(\w+)\s+\"?(.*?)\"?$/) {
                        my ($diskNum, $propName, $propValue) = ($2, $1, $3);
                        chomp($diskNum); chomp($propName); chomp($propValue);
                        $diskNum =~ s/^\s+//; $diskNum =~ s/\s+$//;
                        $propName =~ s/^\s+//; $propName =~ s/\s+$//;
                        $propValue =~ s/^\s+//; $propValue =~ s/\s+$//;

                        if ($propName =~ /^EnclosureConnection/) {
                            if ($propName eq "EnclosureConnectionControllerNumber") {
                                $phyDiskTable{$diskNum}{"CntlrIndex"} = $propValue;
                            }
                            $diskEnclosureTable{$diskNum}{$propName} = $propValue;
                        } elsif ($propName =~ /^LogicalConnection/) {
                            if ($propName eq "LogicalConnectionVirtualDiskNumber") {
                                $phyDiskTable{$diskNum}{"logDiskID"} = $propValue;
                                if ($logDiskTable{$propValue}{"PhyDrvIDs"}) {
                                    $logDiskTable{$propValue}{"PhyDrvIDs"} .= ' ';
                                }
                                $logDiskTable{$propValue}{"PhyDrvIDs"} .= $diskNum;

                                if ($phyDiskTable{$diskNum}{"CntlrIndex"}) {
                                    $logDiskTable{$propValue}{"CntlrIndex"} = $phyDiskTable{$diskNum}{"CntlrIndex"};
                                }
                            }
                        } else {
                            if ($propName eq "LargestContiguousFreeSpaceInMB") {
                                $propName = "LargestContFree";
                            } elsif ($propName eq "SmartAlertIndication") {
                                $propName = "SmartAlert";
                            }
                            if (!($propName =~ /InBytes/)) {
                                $phyDiskTable{$diskNum}{$propName} = $propValue;
                            }
                            if (!$phyDiskTable{$diskNum}{"elementType"}) {
                                $phyDiskTable{$diskNum}{"elementType"} = "dell";
                            }
                        }
                    }
                }
                foreach my $line (split(/\n/, $RAIDLogData)) {
                     if ($line =~ /^virtualDisk(.+?)\.(\w+)\s+\"?(.*?)\"?$/) {
                        my ($diskNum, $propName, $propValue) = ($2, $1, $3);
                        chomp($diskNum); chomp($propName); chomp($propValue);
                        $diskNum =~ s/^\s+//; $diskNum =~ s/\s+$//;
                        $propName =~ s/^\s+//; $propName =~ s/\s+$//;
                        $propValue =~ s/^\s+//; $propValue =~ s/\s+$//;

                        if ($propName eq 'Layout') {
                            if ($propValue eq 'raid-0') {
                                $propValue .= ' (striping)';
                            } elsif ($propValue eq 'raid-1') {
                                $propValue .= ' (mirroring)';
                            } elsif ($propValue eq 'raid-2') {
                                $propValue .= ' (hamming code parity)';
                            } elsif ($propValue eq 'raid-3') {
                                $propValue .= ' (byte level parity)';
                            } elsif ($propValue eq 'raid-4') {
                                $propValue .= ' (block level parity)';
                            } elsif ($propValue eq 'raid-5') {
                                $propValue .= ' (interleave parity)';
                            } elsif ($propValue eq 'raid-6') {
                                $propValue .= ' (dual distributed parity)';
                            }
                        }
                        if (!($propName =~ /InBytes/)) {
                            $logDiskTable{$diskNum}{$propName} = $propValue;
                        }
                        if (!$logDiskTable{$diskNum}{"elementType"}) {
                            $logDiskTable{$diskNum}{"elementType"} = "dell";
                        }
                    }
                }
            } else {
                # Check if it is Compaq RAID Controller
                &echo("Test for Compaq RAID controller. Prior snmpwalk exec result <".$RAIDPhyData.">.");
                $mibdir = "$privateMIBDir/Compaq -M +/usr/share/snmp/mibs";

                if(defined($securityLevel) && $securityLevel ne "") {
                    my $snmp_options_part = $BDNA_Connection_Info{"SNMP_session_options"};
                    $snmp_options = "-M $mibdir -v 3 -Oq -Os $snmp_options_part";
                } else {
                    $snmp_options = "-M $mibdir -v 2c -Oq -Os -c '$community'";
                }

                #$snmp_options = "-M $mibdir -v 2c -Oq -Os -c '$community'";
                $snmp_cmd = "snmpwalk -m CPQIDA-MIB $snmp_options $host:$port ";
                &echo("Executing compaq snmp query: <$snmp_cmd cpqDaPhyDrv>.\n");
                $RAIDPhyData = `$snmp_cmd . 'cpqDaPhyDrv'`;

                if ($RAIDPhyData) {
                    &echo("Compaq RAID Controller Detected.");
                    &echo("Executing compaq snmp query: <$snmp_cmd cpqDaCntlr>.\n");
                    $RAIDCntlrData = `$snmp_cmd . 'cpqDaCntlr'`;
                    &echo("Executing compaq snmp query: <$snmp_cmd cpqDaLogDrv>.\n");
                    $RAIDLogData = `$snmp_cmd . 'cpqDaLogDrv'`;

                    foreach my $line (split(/\n/, $RAIDCntlrData)) {
                        if ($line =~ /cpqDaCntlr(.+?)\.(\d+)\s+\"?(.*?)\"?$/) {
                            my ($cntlrIndex, $propName, $propValue) = ($2, $1, $3);
                            $controllerTable{$cntlrIndex}{$propName} = $propValue;
                            if (!$controllerTable{$cntlrIndex}{"elementType"}) {
                                $controllerTable{$cntlrIndex}{"elementType"} = "compaqCntlr";
                            }
                        }
                    }
                    foreach my $line (split(/\n/, $RAIDLogData)) {
                        if ($line =~ /cpqDaLogDrv(.+?)\.(\w+).(\w+)\s+\"?(.*?)\"?$/) {
                            my ($diskNum, $arrayNum, $propName, $propValue) = ($3, $2, $1, $4);
                            chomp($diskNum); chomp($propName); chomp($propValue);chomp($arrayNum);
                            $diskNum =~ s/^\s+//; $diskNum =~ s/\s+$//;
                            $propName =~ s/^\s+//; $propName =~ s/\s+$//;
                            $propValue =~ s/^\s+//; $propValue =~ s/\s+$//;
                            $arrayNum =~ s/^\s+//; $arrayNum =~ s/\s+$//;

                            $logDiskTable{$diskNum}{$propName} = $propValue;
                            if (!$logDiskTable{$diskNum}{"elementType"}) {
                                $logDiskTable{$diskNum}{"elementType"} = "compaq";
                            }
                        }
                    }
                    foreach my $line (split(/\n/, $RAIDPhyData)) {
                        if ($line =~ /^cpqDaPhyDrv(.+?)\.(\w+).(\w+)\s+\"?(.*?)\"?$/) {
                            my ($diskNum, $arrayNum, $propName, $propValue) = ($3, $2, $1, $4);
                            chomp($diskNum); chomp($propName); chomp($propValue);chomp($arrayNum);
                            $diskNum =~ s/^\s+//; $diskNum =~ s/\s+$//;
                            $propName =~ s/^\s+//; $propName =~ s/\s+$//;
                            $propValue =~ s/^\s+//; $propValue =~ s/\s+$//;
                            $arrayNum =~ s/^\s+//; $arrayNum =~ s/\s+$//;
                            $phyDiskTable{$diskNum}{$propName} = $propValue;
                            if (!$phyDiskTable{$diskNum}{"elementType"}) {
                                $phyDiskTable{$diskNum}{"elementType"} = "compaq";
                            }
                        }
                    }                   
                }
            }
            # Package properties of all controllers
            for my $controllerNum ( keys(%controllerTable) ) {
                my $oneCntlrBuffer = "";
                if ($controllerTable{$controllerNum}{"Number"} || $controllerTable{$controllerNum}{"Index"}) {
                    $cntlrResultBuffer .= '<BDNA,1>elementName="Cntrl_'.$controllerNum.'"<BDNA,2>devID="'.$controllerNum.'"<BDNA,2>';
                }
                if ($controllerTable{$controllerNum}{"elementType"} eq "dellCntlr") {
                    $cntlrResultBuffer .= 'elementType="dellCntlr"<BDNA,2>';
                    if ($controllerTable{$controllerNum}{"Name"}) {
                        $cntlrResultBuffer .= 'name="Dell controller: ' . $controllerTable{$controllerNum}{"Name"} . '"<BDNA,2>' .
                                              'model="' . $controllerTable{$controllerNum}{"Name"} . '"<BDNA,2>';
                    }
                    if ($controllerTable{$controllerNum}{"FWVersion"}) {
                        $cntlrResultBuffer .= 'FWVersion="' . $controllerTable{$controllerNum}{"FWVersion"} . '"<BDNA,2>';
                    }
                    if ($controllerTable{$controllerNum}{"Type"}) {
                        $cntlrResultBuffer .= 'arrayType="' . $controllerTable{$controllerNum}{"Type"} . '"<BDNA,2>';
                    }
                } elsif ($controllerTable{$controllerNum}{"elementType"} eq "compaqCntlr") {
                    $cntlrResultBuffer .= 'elementType="compaqCntlr"<BDNA,2>';
                    if ($controllerTable{$controllerNum}{"Model"}) {
                        $cntlrResultBuffer .= 'name="Compaq controller: ' . $controllerTable{$controllerNum}{"Model"} . '"<BDNA,2>' .
                                              'model="' . $controllerTable{$controllerNum}{"Model"} . '"<BDNA,2>';
                    }
                    if ($controllerTable{$controllerNum}{"FWRev"}) {
                        $cntlrResultBuffer .= 'FWVersion="' . $controllerTable{$controllerNum}{"FWRev"} . '"<BDNA,2>';
                    }
                }
                for my $key ( keys(%{$controllerTable{$controllerNum}}) ) {
                    if (!($key =~ /(^Entry\..+|Number|Index|Model|Name|elementType|FWRev|^FWVersion|StndIntr|Manufacturer|Type)$/)) {
                        my $value = $controllerTable{$controllerNum}{$key};
                        if (!($key =~ /(BGIRate|PCISlot|FWVersion)/)) {
                            $key = lcfirst($key);
                        }
                        if ($oneCntlrBuffer) {
                            $oneCntlrBuffer .= "<BDNA,2>";
                        }
                        $oneCntlrBuffer .= $key . '="'. $value .'"';
                    }
                }
                $cntlrResultBuffer .= $oneCntlrBuffer;
            }
            # Package properties of all physical Disks
            for my $diskNum ( sort keys(%phyDiskTable) ) {
                my $oneDiskBuffer = "";
                if ($phyDiskTable{$diskNum}{"Number"} || $phyDiskTable{$diskNum}{"Index"}) {
                    $phyDiskResultBuffer .= '<BDNA,1>elementName="PhyDisk_'.$diskNum.'"<BDNA,2>devID="'.$diskNum.'"<BDNA,2>';
                }
                if ($phyDiskTable{$diskNum}{"CntlrIndex"}) {
                    $phyDiskResultBuffer .= 'cntlrID="' . $phyDiskTable{$diskNum}{"CntlrIndex"} . '"<BDNA,2>';
                }
                if ($phyDiskTable{$diskNum}{"logDiskID"}) {
                    $phyDiskBuffer .= 'logDiskID="' . $phyDiskTable{$diskNum}{"logDiskID"} . '"<BDNA,2>';
                }

                if ($phyDiskTable{$diskNum}{"elementType"} eq "dell") {
                    $phyDiskResultBuffer .= 'elementType="dell"<BDNA,2>';
                    if ($phyDiskTable{$diskNum}{"Name"}) {
                        $phyDiskResultBuffer .= 'name="' . $phyDiskTable{$diskNum}{"Name"} . '"<BDNA,2>' .
                                                'model="' . $phyDiskTable{$diskNum}{"Name"} . '"<BDNA,2>';
                    }
                    if ($phyDiskTable{$diskNum}{"Revision"}) {
                        $phyDiskResultBuffer .= 'FWVersion="' . $phyDiskTable{$diskNum}{"Revision"} . '"<BDNA,2>';
                    }
                    if ($phyDiskTable{$diskNum}{"SerialNo"}) {
                        $phyDiskResultBuffer .= 'serialNum="' . $phyDiskTable{$diskNum}{"SerialNo"} . '"<BDNA,2>';
                    }
                    if ($phyDiskTable{$diskNum}{"LengthInMB"}) {
                        $phyDiskResultBuffer .= 'devCapacity="' . $phyDiskTable{$diskNum}{"LengthInMB"} . '"<BDNA,2>';
                    }
                } elsif ($phyDiskTable{$diskNum}{"elementType"} eq "compaq") {
                    $phyDiskResultBuffer .= 'elementType="compaq"<BDNA,2>';
                    if ($phyDiskTable{$diskNum}{"Model"}) {
                        $phyDiskResultBuffer .= 'name="' . $phyDiskTable{$diskNum}{"Model"} . '"<BDNA,2>' .
                                                'model="' . $phyDiskTable{$diskNum}{"Model"} . '"<BDNA,2>';
                    }
                    if ($phyDiskTable{$diskNum}{"FWRev"}) {
                        $phyDiskResultBuffer .= 'FWVersion="' . $phyDiskTable{$diskNum}{"FWRev"} . '"<BDNA,2>';
                    }
                    if ($phyDiskTable{$diskNum}{"Size"}) {
                        $phyDiskResultBuffer .= 'devCapacity="' . $phyDiskTable{$diskNum}{"Size"} . '"<BDNA,2>';
                    }
                }

                for my $key ( keys(%{$phyDiskTable{$diskNum}}) ) {
                    if (!($key =~ /^(Entry\..+|Number|HasMonInfo|CntlrIndex|Index|Model|Name|Size|LengthInMB|elementType|Revision|FWRev|^FWVersion|SerialNo|logDiskID|SerialNum|Type|EnclosureID|FunctTest.+)$/)) {

                        my $value = $phyDiskTable{$diskNum}{$key};
                        if (!($key =~ /(SASAddress|FWVersion)/)) {
                            $key = lcfirst($key);
                        }
                        if ($oneDiskBuffer) {
                            $oneDiskBuffer .= "<BDNA,2>";
                        }
                        $oneDiskBuffer .= $key . '="'. $value .'"';
                    }
                }
                $phyDiskResultBuffer .= $oneDiskBuffer;
            }
            # Package properties of all logical Disks
            for my $diskNum ( sort keys(%logDiskTable) ) {
                my $oneDiskBuffer = "";
                if ($logDiskTable{$diskNum}{"Number"} || $logDiskTable{$diskNum}{"Index"}) {
                    $logDiskResultBuffer .= '<BDNA,1>elementName="LogDisk_'.$diskNum.'"<BDNA,2>devID="'.$diskNum.'"<BDNA,2>';
                }
                if ($logDiskTable{$diskNum}{"CntlrIndex"}) {
                    $logDiskResultBuffer .= 'cntlrID="' . $logDiskTable{$diskNum}{"CntlrIndex"} . '"<BDNA,2>';
                }
                if ($logDiskTable{$diskNum}{"PhyDrvIDs"}) {
                    my $ids = join(',' , split(/\s/, $logDiskTable{$diskNum}{"PhyDrvIDs"}));
                    $logDiskResultBuffer .= 'phyDiskIDs="' . ','.$ids.',' . '"<BDNA,2>';
                }
                if ($logDiskTable{$diskNum}{"elementType"} eq "dell") {
                    $logDiskResultBuffer .= 'elementType="dell"<BDNA,2>';
                    if ($logDiskTable{$diskNum}{"Name"}) {
                        $logDiskResultBuffer .= 'name="' . $logDiskTable{$diskNum}{"Name"} . '"<BDNA,2>';
                        if ($logDiskTable{"DeviceName"}) {
                            $logDiskResultBuffer .= 'osDevName="' . $logDiskTable{$diskNum}{"DeviceName"} . '"<BDNA,2>';
                        } else {
                            $logDiskResultBuffer .= 'osDevName="' . $logDiskTable{$diskNum}{"Name"} . '<BDNA,2>';
                        }                        
                    }
                    if ($logDiskTable{$diskNum}{"LengthInMB"}) {
                        $logDiskResultBuffer .= 'devCapacity="' . $logDiskTable{$diskNum}{"LengthInMB"} . '"<BDNA,2>';
                    }
                } elsif ($logDiskTable{$diskNum}{"elementType"} eq "compaq") {
                    $logDiskResultBuffer .= 'elementType="compaq"<BDNA,2>';
                    if ($logDiskTable{$diskNum}{"OsName"}) {
                        $logDiskResultBuffer .= 'name="' . $logDiskTable{$diskNum}{"OsName"} . '"<BDNA,2>' .
                                                'osDevName="'. $logDiskTable{$diskNum}{"OsName"} . '"<BDNA,2>';

                    }
                    if ($logDiskTable{$diskNum}{"Size"}) {
                        $logDiskResultBuffer .= 'devCapacity="' . $logDiskTable{$diskNum}{"Size"} . '"<BDNA,2>';
                    }
                }

                for my $key ( keys(%{$logDiskTable{$diskNum}}) ) {
                    if (!($key =~ /(Number|Index|Name|DeviceName|OsName|PhyDrvIDs|CntlrIndex|Size|LengthInMB|elementType)/)) {
                        my $value = $logDiskTable{$diskNum}{$key};
                        $key = lcfirst($key);
                        if ($oneDiskBuffer) {
                            $oneDiskBuffer .= "<BDNA,2>";
                        }
                        $oneDiskBuffer .= $key . '="'. $value .'"';
                    }
                }
                $logDiskResultBuffer .= $oneDiskBuffer;
            }
        }
        &echo("phyDiskResultBuffer='$phyDiskResultBuffer'");
        if ($phyDiskResultBuffer =~ /<BDNA,1>elementName="PhyDisk_.+"<BDNA,2>/) {
            $BDNA_Results{"physicalDisks"} = $phyDiskResultBuffer;
        }
        if (!$BDNA_Results{"physicalDisks"}) {
            $BDNA_Results{"RAIDPhyData"} = $RAIDPhyData;
        }
        &echo("cntlrResultBuffer='$cntlrResultBuffer'");
        if ($cntlrResultBuffer=~ /<BDNA,1>elementName="Cntrl_.+"<BDNA,2>/) {
            $BDNA_Results{"RAIDControllers"} = $cntlrResultBuffer;
        }
        if (!$BDNA_Results{"RAIDControllers"}) {
            $BDNA_Results{"RAIDCntlrData"} = $RAIDCntlrData;
        }
        $BDNA_Results{"logicalDisks"} = $logDiskResultBuffer;
        if (!$BDNA_Results{"logicalDisks"}) {
            $BDNA_Results{"RAIDLogData"} = $RAIDLogData;
        }
        $BDNA_ErrorCode = 0;
        $BDNA_ResultCode = "com.bdna.cle.scripts.success";
        $BDNA_MessageBundle = "MessagesBundle";
        ]]>
    </scriptTable>
    
    
    <!-- Windows specific rule -->    
    <matchRule name="createDeviceForWindows" 
            lookupOnly="false"      
            sourceTypeFullName="root.types.resource.software.operatingSystem.Windows"
            targetTypeFullName="root.types.resource.device" 
            minMatches="2"
            minAttributes="3" >

            <matchRuleAttribute sourceAttributeName="bdnaUniqueID" targetAttributeName="bdnaUniqueID" />            
            <matchRuleAttribute sourceAttributeName="systemMacAddresses" targetAttributeName="systemMacAddresses" />      
            <matchRuleAttribute sourceAttributeName="hwIdentNum" targetAttributeName="hwIdentNum" />            
            <matchRuleAttribute sourceAttributeName="hwUUID" targetAttributeName="hwUUID" />            

            <createXML><![CDATA[ 
                my @props = ( 'osComputerName', 'bdnaUniqueID', 'hwUUID', 'systemMacAddresses', 'hwIdentNum', 'volumeSN');
                $result = "<result>" .
                          &createDeviceXML(\%source, \@props) .
                          "</result>";
            ]]></createXML>

            <updateXML><![CDATA[ 
                my @props = ( 'osComputerName', 'bdnaUniqueID', 'hwUUID', 'systemMacAddresses','hwIdentNum', 'volumeSN');
                $result = "<result>" .
                          &updateDeviceXML(\%source, \%target, \@props) .
                          "</result>";
            ]]></updateXML>
    </matchRule>    
</module>
